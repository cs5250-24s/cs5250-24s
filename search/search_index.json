{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#overview","title":"Overview","text":"<p>In this course, we will have 4 assignments. Tentatively, we will follow the schedule below.</p> Assignment Release Due Assignment 1 Mon, 22 Jan 2024 Mon, 12 Feb 2024 Assignment 2 Mon, 12 Feb 2024 Mon, 11 Mar 2024 Assignment 3 Mon, 11 Mar 2024 Mon, 1 Apr 2024 Assignment 4 Mon, 1 Apr 2024 Mon, 22 Apr 2024 <p>The maximum score for an assignment is 50 marks. Each assignment will include two parts, i.e., Part A (35 marks) and Part B (15 marks). Part A includes some hands-on practice to make you explore aspects about Linux kernel. Part B includes some exercises that test your understanding on the topics covered in the lectures.</p> <p>Assignments are always due at 17:59 on some Monday. Late submissions will incur a penalty of 1 mark per hour.</p>"},{"location":"#academic-integrity","title":"Academic Integrity","text":"<p>The assignments in this course are all INDIVIDUAL assignments.</p> <p>The assignments are primarily designed as practical experiences to enhance your skills and knowledge. Plagiarism not only negate the benefits of this assignment, but also defeats the purpose of taking the course. These assignments are structured to foster your learning, not to fail students.</p> <p>Plagiarism will not be tolerated and will result in severe consequences in accordance with the University's policy.</p>"},{"location":"#collaboration-and-proper-attribution","title":"Collaboration and Proper Attribution","text":"<p>While collaboration is acceptable to some extent, the assignment questions and tasks should be approached independently. If you receive assistance from classmates, friends, or external resources, you must provide appropriate citations in your submission.</p>"},{"location":"#file-sharing","title":"File Sharing","text":"<p>It is strictly prohibited to share your solution files with individual students or through public channels, such as blog posts. Solution files must not be stored in unprotected directories or repositories. If you use a code repository, like GitHub, ensure that it remains private even after the course concludes. Do not open source your code.</p>"},{"location":"#proper-use-of-ai-tools","title":"Proper Use of AI Tools","text":"<p>We encourage the legitimate and responsible use of AI tools, including ChatGPT, Bard, Bing Chat, and Copilot, to enrich your learning experience.</p> <p>These AI tools can be employed for various educational purposes:</p> <ul> <li>You can seek assistance in proofreading and editing your writing to improve the quality of your work.</li> <li>You can use AI tools to seek explanations for basic concepts, aiding your understanding of course materials.</li> <li>You may request help in explaining pieces of code.</li> </ul> <p>It is strictly prohibited to engage in the following actions:</p> <ul> <li>You must not ask AI tools to generate code on your behalf.</li> <li>You are prohibited from generating content and presenting it as your own work or idea, whether directly or through paraphrasing.</li> <li>Do not use AI tools to process resources not created by you with the intention to plagiarize.</li> </ul>"},{"location":"#general-advice","title":"General Advice","text":"<ul> <li>When submitting code, it is essential to ensure that the code compiles without errors.   A compilation error will result in a score of ZERO for that question.</li> <li>Use the root user (or <code>sudo</code>) ONLY for operations that really require super-user privileges.   Why is it bad to log in as root?</li> <li>Pay close attention to instructions and tips.   A thorough understanding will save your time and effort.</li> <li>Don't fear making mistakes; they're part of the learning process.   Understand that you can always start over and seek help when needed.</li> <li>When you encounter errors, read the messages carefully, especially the first one issued.   They often hold the key to resolving issues.</li> <li>Hone your problem-solving skills by harnessing the vast knowledge available online.</li> </ul>"},{"location":"#feedback","title":"Feedback","text":"<p>If you have any feedback on this assignment, please mail to your TA.</p>"},{"location":"asg1/","title":"Introduction","text":"<p>Info</p> <p>Please read the general instructions first.</p> <p>The assignment is due 17:59 on 12 Feb 2024.   Late submissions will lose 1 mark per hour.</p> <p>Info</p> <p>These assignments are designed under the assumption that you are using an x86-64 machine.   If you do not have access to a machine based on the x86 architecture, you have the option to request a server for your use.   To proceed with a server request, please complete and submit this quiz.   However, in order to ensure the efficient use of resources, we kindly ask that you request a server only if there are no other viable alternatives.</p>"},{"location":"asg1/#part-a-35-marks","title":"Part A (35 marks)","text":""},{"location":"asg1/#task-1-setup-a-virtual-machine","title":"Task 1: Setup a Virtual Machine","text":"<p>Question 1 (3 marks): What is the command needed inside the VM to make your shared folder accessible? Please explain the arguments of the command.</p>"},{"location":"asg1/#task-2-build-and-install-linux-kernel","title":"Task 2: Build and Install Linux Kernel","text":"<p>Question 2 (10 marks): Please submit the DEB package <code>linux-image-6.7.0..._amd64.deb</code> containing your customized smaller kernel.</p>"},{"location":"asg1/#task-3-explore-the-boot-process","title":"Task 3: Explore the Boot Process","text":"<p>Question 3 (5 marks): Please submit the BIOS image <code>bios.bin</code> which prints out your Matric No.</p> <p>Question 4 (5 marks): You'll notice that most of the executable files under the <code>_install/bin</code> directory are merely links to the <code>busybox</code> executable. Interestingly, despite being links, each of these files can be executed and behaves differently.</p> <p>Try to understand how this functionality is achieved and explain the underlying concept with a brief code snippet.</p> <p>To demonstrate your understanding, you are required to write a C program named <code>dispatch.c</code>. This program should be compiled into an executable named <code>dispatch</code>. When a link (with different names) to <code>dispatch</code> is executed, it should output different messages based on the filename of the link.</p> <p>Here are the expected outputs for different filenames:</p> Filename Expected Output <code>hello</code> Prints <code>Hello World!</code> <code>user</code> Prints the current username <code>kernel</code> Prints the kernel release version of the current system (e.g., <code>6.7.0-14-generic</code>) <p>Here's an example of how the program should behave:</p> <p></p> <p>Question 5 (8 marks): Please submit the initramfs image <code>initramfs.cpio.gz</code> which can switch to the root filesystem.</p> <p>Question 6 (4 marks): Where is the command line argument <code>systemd.unit=rescue.target</code> accepted in the boot process? Is it processed by the BIOS, Kernel, Initramfs, or after switching to the root filesystem? Please explain your answer.</p>"},{"location":"asg1/#submission-guidelines","title":"Submission Guidelines","text":"<p>For this assignment, you are required to answer Questions 1 and 6 in separate Markdown files. If you're unfamiliar with Markdown syntax, you can find numerous online tutorials, such as the one available at CommonMark.</p> <p>Your submission should be a zip file containing the following files:</p> Filename Description <code>qn1.md</code> Your response to Question 1, formatted in Markdown. <code>linux-image-6.7.0..._amd64.deb</code> A DEB package that includes your custom, reduced-size kernel. <code>bios.bin</code> A BIOS image that displays your Matriculation Number. <code>dispatch.c</code> A C program that behaves differently depending on the name of the executable. <code>initramfs.cpio.gz</code> An initramfs image that displays your Matriculation Number before switching to the root filesystem. <code>qn6.md</code> Your response to Question 6, formatted in Markdown. <p>You can verify the contents of your zip file using the <code>unzip -l</code> command. Please note that the files listed above are for illustrative purposes only. The actual files in your submission should not be empty.</p> <pre><code>$ zip asg1.zip bios.bin dispatch.c initramfs.cpio.gz linux-image-6.7.0*_amd64.deb qn1.md qn6.md\n  adding: bios.bin (stored 0%)\n  adding: dispatch.c (stored 0%)\n  adding: initramfs.cpio.gz (stored 0%)\n  adding: linux-image-6.7.0_6.7.0-3_amd64.deb (stored 0%)\n  adding: qn1.md (stored 0%)\n  adding: qn6.md (stored 0%)\n$ unzip -l asg1.zip\nArchive:  asg1.zip\n  Length      Date    Time    Name\n---------  ---------- -----   ----\n        0  2024-01-15 19:17   bios.bin\n        0  2024-01-15 19:17   dispatch.c\n        0  2024-01-15 19:17   initramfs.cpio.gz\n        0  2024-01-15 19:17   linux-image-6.7.0_6.7.0-3_amd64.deb\n        0  2024-01-15 19:17   qn1.md\n        0  2024-01-15 19:17   qn6.md\n---------                     -------\n        0                     6 files\n</code></pre> <p>Warning</p> <p>Your zip file shall have only one file ending with \".deb\". If you have more than one file ending with \".deb\", you will lose additional marks.</p> <p>Please submit your zip file to Assignment 1 (Part A) on Canvas.</p>"},{"location":"asg1/#part-b-15-marks","title":"Part B (15 marks)","text":"<p>Please complete the quiz Assignment 1 (Part B) on Canvas.</p>"},{"location":"asg1/task-boot/","title":"Task 3: Experience the Boot Sequence","text":""},{"location":"asg1/task-boot/#installing-qemu","title":"Installing QEMU","text":"<p>QEMU is an open-source machine emulator that allows you to run virtual machines and emulate different architectures on your own system. In this task, we will be leveraging the flexibility of QEMU, particularly its ability to specify a custom firmware or boot directly from a kernel image.</p> <p>To install QEMU on your local machine, open your terminal and execute the following command:</p> <pre><code>sudo apt install qemu-system-x86\n</code></pre> <p>After installing QEMU, you can start using it by running the following command:</p> <pre><code>qemu-system-x86_64 -nographic\n</code></pre> <p>Upon execution, you'll see some output starting with <code>SeaBIOS (version 1.xxx)</code>, followed by some boot attempts. Since we are not providing any bootable image at this point, it's normal for the booting process to fail or hang.</p> <p>You can quit QEMU by pressing <code>Ctrl-a</code> then <code>x</code>. For more commands in this mode, please refer to the manual.</p>"},{"location":"asg1/task-boot/#building-seabios","title":"Building SeaBIOS","text":"<p>SeaBIOS is an open-source implementation of x86 BIOS.</p> <p>First, clone the SeaBIOS repository to get a copy of the source code. You can do this by executing the following command in your terminal:</p> <pre><code>git clone https://git.seabios.org/seabios.git\n</code></pre> <p>Navigate to the cloned repository and build SeaBIOS using the <code>make</code> command.</p> <pre><code>cd seabios &amp;&amp; make\n</code></pre> <p>This will generate a file named <code>bios.bin</code> in the <code>out</code> directory. You can boot into SeaBIOS using the <code>bios.bin</code> file you just built. Run the following command:</p> <pre><code>qemu-system-x86_64 -nographic -bios out/bios.bin\n</code></pre> <p>Upon successful execution, the output should start with <code>SeaBIOS (version rel-1.16.3-xxxxx)</code>. This version should be later than the one you saw previously, indicating that you have successfully booted into the newly built SeaBIOS.</p> <p>Please modify the source code so that your Matric No. (AxxxxxxxY) is printed out below the SeaBIOS version. Submit the <code>out/bios.bin</code> file.</p>"},{"location":"asg1/task-boot/#building-linux-kernel","title":"Building Linux Kernel","text":"<p>You should have already built the kernel in the previous task.</p>"},{"location":"asg1/task-boot/#building-an-initramfs","title":"Building an Initramfs","text":""},{"location":"asg1/task-boot/#create-a-simple-initramfs","title":"Create a Simple Initramfs","text":"<p>Write a C program named <code>init.c</code> that prints out a message of your choice. Be creative with your message.</p> <pre><code>// Example of init.c\n#include &lt;stdio.h&gt;\n\nint main() {\n    printf(\"Hello, World!\\n\");\n    return 0;\n}\n</code></pre> <p>Compile your program statically using the command below. This will create an executable named <code>init</code>.</p> <pre><code>gcc -static -o init init.c\n</code></pre> <p>Create a new directory and move the <code>init</code> executable into it. Ensure that the <code>init</code> executable is the only file in this directory. Generate an initramfs from the directory containing your <code>init</code> executable using the following command:</p> <pre><code>find . | cpio -H newc -o | gzip &gt; initramfs.cpio.gz\n</code></pre> <p>Boot into the kernel using your newly created initramfs by executing the following command:</p> <pre><code>qemu-system-x86_64 -nographic -append \"console=ttyS0\" -kernel /path/to/bzImage -initrd /path/to/initramfs.cpio.gz\n</code></pre> <p>Replace <code>/path/to/bzImage</code> and <code>/path/to/initramfs.cpio.gz</code> with the actual paths to your kernel image and initramfs respectively.</p> <p>You will encounter a kernel panic. But don't panic! Look for the lines <code>Run /init as init process</code> and <code>Kernel panic - not syncing: Attempted to kill init!</code>. Your message should appear between these two lines. If you see your message, you've successfully built and booted an initramfs.</p>"},{"location":"asg1/task-boot/#create-an-initramfs-using-busybox","title":"Create an Initramfs using BusyBox","text":"<p>Start by downloading the latest stable version of the BusyBox source code from the official website: BusyBox. After downloading, extract the source code and navigate to the directory containing the extracted source code.</p> <p>Next, create a configuration using the <code>make menuconfig</code> command. During this process, ensure that you select the \"Build static binary (no shared libs)\" option under \"Settings\". Then, build the source code using <code>make</code> command.</p> <p>After building the source code, install BusyBox using the <code>make install</code> command. This will install BusyBox to the <code>_install</code> directory.</p> <p>Next, create an <code>init</code> script in the <code>_install</code> directory. This script will directly drop to a shell. Here's a sample script, remember to replace <code>&lt;your name&gt;</code> and <code>&lt;your Matric No.&gt;</code> with your actual name and Matric No.:</p> <pre><code>#!/bin/sh\n\nset -ex\necho \"Hello, &lt;your name&gt; (&lt;your Matric No.&gt;)\"\nexec /bin/sh\n</code></pre> <p>The <code>set -ex</code> command facilitates debugging by printing each command before executing it and exiting immediately if any command fails. Remember to make the script executable using the following command:</p> <pre><code>chmod +x init\n</code></pre> <p>Finally, pack all the files in the <code>_install</code> directory into an initramfs using the command used previously. You may use QEMU to test if it works.</p>"},{"location":"asg1/task-boot/#booting-into-ubuntu","title":"Booting into Ubuntu","text":""},{"location":"asg1/task-boot/#create-a-hard-disk-image-for-the-ubuntu-root-filesystem","title":"Create a Hard Disk Image for the Ubuntu Root Filesystem","text":"<p>Download the Ubuntu 22.04 minimal cloud image from the following link: Ubuntu 22.04 minimal cloud image</p> <p>We will be creating a hard disk image using the downloaded files. First, create a file that is large enough to hold the root filesystem. In this example, we will create a 16 GiB file and format it as an ext4 filesystem using the following commands:</p> <pre><code>fallocate -l 16GiB rootfs.img\nmkfs.ext4 rootfs.img\n</code></pre> <p>Next, mount the image at a temporary location, extract the root filesystem into it, and then unmount it. You can do this using the following commands:</p> <pre><code>mkdir rootfs\nsudo mount -o loop ./rootfs.img ./rootfs\nsudo tar xf ubuntu-22.04-minimal-cloudimg-amd64-root.tar.xz -C rootfs\nsudo umount rootfs\n</code></pre> <p>At this point, the <code>rootfs.img</code> file is a hard disk image that is ready to be used as a root filesystem.</p>"},{"location":"asg1/task-boot/#switch-to-rootfs-from-initramfs","title":"Switch to rootfs from initramfs","text":"<p>BusyBox provides a <code>switch_root</code> command that can be used to switch to a new root filesystem. You will need to find out how to use this command and modify the <code>init</code> script accordingly to switch to the root filesystem.</p> <p>You can then boot into the root filesystem using the following command:</p> <pre><code>qemu-system-x86_64 -nographic -kernel bzImage -initrd busybox.cpio.gz -append 'console=ttyS0' rootfs.img\n</code></pre> <p>Info</p> <ul> <li>The <code>rootfs.img</code> is equivalent to a hard disk in the virtual machine launched by QEMU.</li> <li>You will need to have \"proc\" and \"devtmpfs\" mounted in the init script.</li> </ul>"},{"location":"asg1/task-boot/#create-a-user","title":"Create a User","text":"<p>The root filesystem that we created does not have any users, which means you cannot log in to it. To create a user, we will boot into the system in single-user mode (rescue mode) and use the <code>useradd</code> command. To boot into rescue mode, add <code>systemd.unit=rescue.target</code> to the kernel command line using the following command:</p> <pre><code>qemu-system-x86_64 -nographic -kernel bzImage -initrd busybox.cpio.gz -append 'console=ttyS0 systemd.unit=rescue.target' rootfs.img\n</code></pre> <p>Once in rescue mode, you can create a user using the <code>useradd</code> command. Please search online for instructions on how to use this command to create a user.</p>"},{"location":"asg1/task-kbuild/","title":"Task 2: Build and Install Linux Kernel","text":"<p>Warning</p> <p>If you are using the course-provided server, kindly perform this task within your VM. At no point should you attempt to install the kernel built by yourself directly in the server.</p>"},{"location":"asg1/task-kbuild/#kernel-source-code","title":"Kernel Source Code","text":"<p>To access the Linux kernel releases, visit the official website at https://www.kernel.org. These releases fall into several main categories: mainline, stable, and long-term. For more information on the different categories, please check this page.</p> <p>In this course, we will work with the latest stable release when the course begins, which is Linux 6.7. You can find the repository for the mainline tree at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git and the repository for the stable tree at https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git.</p> <p>To obtain a local copy of the code, we have two options:</p> <ol> <li>Download a release.</li> <li>Clone the repository.</li> </ol> <p>You can choose the method that best suits your needs, as different tasks may require different approaches.</p>"},{"location":"asg1/task-kbuild/#cloning-the-tree","title":"Cloning the Tree","text":"<p>To work with Linux kernel sources and perform tasks such as generating a patch, you'll need to clone the git tree. Use the following command to clone the repository:</p> <pre><code>git clone https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git --depth 1 --branch v6.7\n</code></pre> <p>Here's what each option does:</p> <ul> <li> <p><code>--depth 1</code>:</p> <p>Creates a shallow clone with the history truncated to only one commit, reducing the size of downloaded git objects.</p> </li> </ul> <ul> <li> <p><code>--branch xxx</code>:</p> <p>Specifies the branch (or tag) to clone.</p> </li> </ul>"},{"location":"asg1/task-kbuild/#downloading-kernel-source-code","title":"Downloading Kernel Source Code","text":"<p>To download a kernel source code release, visit this link: https://cdn.kernel.org/pub/linux/kernel/v6.x/linux-6.7.tar.xz.</p> <p>All kernel releases are cryptographically signed. To ensure the integrity of your downloaded kernel releases, follow the instructions provided here.</p>"},{"location":"asg1/task-kbuild/#check-the-version","title":"Check the Version","text":"<p>Execute the following command to check which version you currently have:</p> <pre><code>make kernelversion\n</code></pre> <p>If you obtained the kernel source code by cloning the repository, you may also check the commit history:</p> <pre><code>git log -1\n</code></pre>"},{"location":"asg1/task-kbuild/#kernel-building","title":"Kernel Building","text":"<p>Additional dependencies</p> <p>In this part, you may encounter errors like:</p> <ul> <li>Command not found: <code>xxx</code></li> <li>Unable to find <code>xxx</code> package</li> <li>...</li> </ul> <p>This indicates that specific programs, libraries, or headers are missing on your machine. You'll need to install the necessary dependencies. Typically, this involves installing Ubuntu software packages required for kernel building. As you continue, you'll become more comfortable with this process.</p> <ol> <li> <p><code>make defconfig</code></p> <p>This will create a default configuration file for the kernel.</p> </li> <li> <p><code>make -j$(nproc)</code></p> <p>Compiling the kernel is a time-consuming task, and it may take a while.  While you wait, you can think about ways to optimize the process for future builds.  Patience is key during this step.</p> </li> </ol>"},{"location":"asg1/task-kbuild/#install-linux-kernel","title":"Install Linux Kernel","text":"<ol> <li> <p><code>make modules_install</code></p> <p>This command is used to install kernel modules.</p> </li> <li> <p><code>make install</code></p> <p>This command is responsible for installing the newly built kernel.  It's the final step in getting your custom kernel ready for use.  Please try to find out which directory the kernel image is installed to.</p> </li> </ol>"},{"location":"asg1/task-kbuild/#configure-grub","title":"Configure GRUB","text":"<p>The kernel image is now in the correct location. However, the bootloader might not be aware of it yet.</p> <p>The boot order of the operating systems is specified in <code>/boot/grub/grub.cfg</code>. By updating this file, you can modify the default OS, the sequence of different kernel releases, and the behaviour of the GRUB menu.</p> <p>Try to figure out how to update this file (or how the file is updated). The original settings in related files and some online research will be very helpful. Please note that root privileges are required for this step.</p> <p>If this is your first time performing this operation, it is recommended to create a backup or snapshot before proceeding.</p> <p>After rebooting, check whether the boot option appears as expected. (Additional configuration may be necessary to make the GRUB menu appear on boot.)</p> <p></p> <p>If everything goes well, you should see the login prompt. After logging in, some messages (motd) will be printed out. The kernel release version, which should have changed to the new one, is reflected in the first line.</p> <p>Info</p> <p>It is expected that the new kernel will start up without any problems. If something does go wrong, check the error messages and try to figure out what caused the issue. You may ask your friends or the TA for help if you get stuck at this step.</p>"},{"location":"asg1/task-kbuild/#customize-the-kernel-build","title":"Customize the Kernel Build","text":"<p>In this task, you will build a smaller kernel image that will successfully boot up on your virtual machine. You can do so by customizing the kernel configuration and removing unnecessary features.</p>"},{"location":"asg1/task-kbuild/#menuconfig","title":"menuconfig","text":"<p>To customize the kernel configuration, you may use the <code>menuconfig</code> tool.</p> <pre><code>make menuconfig\n</code></pre> <p>This command will open a menu that allows you to customize the kernel configuration. </p> <p>You will typically encounter three options for most features: <code>built-in</code>, <code>excluded</code>, and <code>module</code>. What do these choices mean, and which one(s) cause the related functions to be included in the kernel image?</p> <p>Feel free to explore other ways to update the config. You may start from checking the information from <code>make help</code>.</p>"},{"location":"asg1/task-kbuild/#shrink-the-kernel-image","title":"Shrink the Kernel Image","text":"<p>Please try to shrink the kernel image by removing unnecessary features. Please note:</p> <ul> <li>Keep the original kernel for comparison.</li> <li>Give your smaller kernel a different name from the one built in the previous task.   You can customize the kernel release version by updating <code>LOCALVERSION</code> in the kernel config to identify your kernel images.   Use the search function of <code>menuconfig</code> to find where to modify the option.</li> <li>Your goal is to reduce the size of the kernel image (<code>./arch/x86/boot/bzImage</code>) to less than 8 MiB.   There's no need to shrink it excessively.</li> <li>To ensure that the VM has successfully booted up, verify that the VM reaches the same login screen as your original kernel.</li> </ul> <p>Info</p> <p>When you attempt to boot with your new kernel after removing certain features, expect something strange to happen. It's a good idea to document the changes you made to the kernel configuration. This record will be handy in figuring out the cause of any issues that arise. This part of the assignment is designed to prompt you to observe the effects of disabling specific features, understand their importance, and then work on fixing any resulting problems.</p> <p>For your submission, build your customized kernel into a DEB package using the following command:</p> <pre><code>make bindeb-pkg\n</code></pre> <p>You may need additional dependencies to build the DEB package successfully. After doing so, several new files should be generated in the parent folder (not the current directory). Submit the file whose name starts with <code>linux-image</code>. You can check the file using the commands below:</p> <ol> <li><code>dpkg -c linux-image-6.7..._amd64.deb</code>    This command lists the contents of the DEB package.    Inside the package, there should be a file named <code>./boot/vmlinuz-6.7...</code>.    If not, you might be looking at the wrong file.</li> <li> <p><code>dpkg -f linux-image-6.7..._amd64.deb Maintainer</code>    This command extracts the <code>Maintainer</code> information from the control file in the DEB package.    The output should be like:</p> <pre><code>user &lt;user@hostname&gt;\n</code></pre> <p>Please note: <code>user</code> should not be <code>root</code> and <code>hostname</code> should start with your NUSNET ID.</p> </li> </ol>"},{"location":"asg1/task-vm/","title":"Task 1: Setup a Virtual Machine","text":"<p>It is common to have problems during the setup stage. Try to figure it out yourself first. Remember to read the error messages carefully and search online for solutions. The abilities to search and debug is crucial in dealing with Linux.</p> <p>However, if you cannot find solutions after you try all approaches you can think of, feel free to discuss it with your classmates or email the TA.</p> <p>Not Using an x86 Machine?</p> <p>These assignments are designed with the assumption that you're using an x86-64 machine. If you don't have access to an x86-based machine, you should have already requested a server for your assignments.</p> <p>Please note that you won't have access to the graphical interface of the remote machine, so additional steps may be required. Refer to the relevant tabs for instructions tailored to your situation.</p> Local MachineRemote Server <p>These instructions are for students who are using their own x86 machines.</p> <p>These instructions are for students who are using the remote server provided by the course.</p>"},{"location":"asg1/task-vm/#install-virtualbox-on-your-machine","title":"Install VirtualBox on your machine","text":"Local MachineRemote Server <p>VirtualBox is an open-source software that runs on most common platforms. Please download the latest version from page and install it on your machine. It should work on all major x86-based platforms.</p> <p>You'll still be working with VirtualBox.</p> <p>For some part of the assignments, working in a virtual machine under you control is necessary, even though the server is already installed with Ubuntu. To do this, please download the latest version of VirtualBox and the extension pack from its website. You may install the extension pack using the command documented here.</p> <p>The version of VirtualBox in the Ubuntu repository might not be compatible with the OS running on the server.</p>"},{"location":"asg1/task-vm/#download-an-iso-image-of-linux-ubuntu","title":"Download an ISO image of Linux Ubuntu","text":"<p>You can download the Ubuntu 22.04 Server install image for a 64-bit machine from the provided link. Alternatively, you can obtain the installation image from Ubuntu's official website.</p> <p>You also have the option to download the desktop version, which comes with GUI support but demands more resources. The following instructions will presume the use of the server version.</p>"},{"location":"asg1/task-vm/#create-a-new-virtual-machine","title":"Create a new Virtual Machine","text":"Local MachineRemote Server <ol> <li>Start VirtualBox</li> <li>Click \"New\" button in the Oracle VM VirtualBox Manager.</li> <li>Click \"Expert Mode\" button at the bottom.</li> <li>Use the setting listed below<ul> <li>Name and the Operating System<ul> <li>Name: CS5250 (or anything you like)</li> <li>ISO Image: Choose the ISO file you downloaded</li> <li>Type: Linux</li> <li>Version: Ubuntu (64-bit)</li> <li>Check \"Skip Unattended Installation\"</li> </ul> </li> <li>Hardware<ul> <li>Base Memory: 1024 MB (or larger, you can change this when needed)</li> <li>Processors: 2 (or more, you can change this when needed)</li> </ul> </li> <li>Hard Disk<ul> <li>Create a virtual hard disk now.</li> <li>Allocate at least 40 GB</li> </ul> </li> </ul> </li> <li>Click \"Finish\"</li> </ol> <p>To run VirtualBox on a remote server without a GUI environment, you will use the <code>VBoxManage</code> command to create and manage your virtual machine. You can then connect to it from your local machine via the Remote Desktop Protocol.</p> <p>For an overview of how to create a VM on a headless server, refer to Section 7.1.3. Keep the following points in mind:</p> <ul> <li>The example provided in the manual is for Windows XP, but we intend to use Linux as the Guest OS.   Adjust the <code>ostype</code> accordingly to match your requirements.   You may find the list of supported OS types using <code>VBoxManage list</code> command (see here).</li> <li>When configuring your VM, choose an appropriate number of CPUs, memory size, and virtual hard disk size.   We recommend setting it to 2 CPUs, 2 GB of memory, and 40 GB of disk space.</li> </ul>"},{"location":"asg1/task-vm/#launch-and-install-os-for-your-vm","title":"Launch and Install OS for your VM","text":"Local MachineRemote Server <p>Start your virtual machine by clicking \"Start\" in VirtualBox Manager, and install Ubuntu as guided.</p> <p>Ensure that you have an RDP client installed on your local machine. For Mac users, you can consider using \"Microsoft Remote Desktop\" from the App Store.</p> <p>The VRDP server that comes with VirtualBox typically uses TCP port 3389 by default. However, for security reasons, this port is disabled using ufw. You should use SSH port forwarding by executing the following command on your local machine:</p> <pre><code>ssh -L 3389:localhost:3389 &lt;username&gt;@&lt;server-ip&gt;\n</code></pre> <p>This command establishes a secure SSH tunnel, forwarding traffic from port 3389 on your local machine to the same port on the server, facilitating secure access to the VRDP server on the remote machine as if it were running locally.</p> <p>Refer to the manual for guidance on starting the virtual machine using the <code>VBoxHeadless</code> command with VRDE enabled. Once initiated, connect to the virtual machine using your RDP client. Since the port has been forwarded to your local machine, set the IP as either <code>localhost</code> or <code>127.0.0.1</code>. </p> <p>Follow the guided installation process to install Ubuntu on your virtual machine.</p> <p>Note: Mac keyboards have a different layout from the standard ANSI or ISO ones. On the \"Keyboard configuration\" step, you may try the \"Keyboard Variant\" ending with <code>(Macintosh)</code> as one option to consider.</p> <p>Please take note of the following settings:</p> <ul> <li>Profile Setup:<ul> <li>Name: Enter your full name.</li> <li>Server's Name: Choose a name that starts with your NUSNET ID.</li> <li>Username: Choose a username that is formed from your real name.</li> <li>Password: Choose a secure password.</li> </ul> </li> <li>SSH Setup:<ul> <li>Ensure to check the \"Install OpenSSH server\" option.</li> </ul> </li> </ul>"},{"location":"asg1/task-vm/#login","title":"Login","text":"<p>After reboot, you shall see some logs doing initial setup, which is output by \"cloud-init\". When it is done, press \"Enter\" and you should see the login prompt</p> <pre><code>hostname login:\n</code></pre> <p>To login, input your username, press \"Enter\", and then input your password as required. And you will see the bash prompt</p> <pre><code>user@hostname:~$\n</code></pre> <p>As a beginner, you may try to find and print the information below.</p> <ul> <li>The OS version and the kernel release version</li> <li>The IP address allocated, and your MAC address</li> </ul>"},{"location":"asg1/task-vm/#setting-up-shared-folder","title":"Setting Up Shared Folder","text":"<p>A shared folder is a directory or folder that can be accessed and used by both the host machine (where VirtualBox is installed) and the guest virtual machine (VM) running within VirtualBox. This feature allows for the seamless exchange of files between the host<sup>1</sup> and the VM. Please create a shared folder on your host machine and share it with the VM.</p>"},{"location":"asg1/task-vm/#setting-up-ssh-connection-optional","title":"Setting Up SSH Connection (Optional)","text":"<p>Configure the virtual machine to allow for connection via SSH from the host<sup>1</sup> machine. This will enable you to attach VSCode to the VM, providing a superior experience compared to using the terminal inside the VM. Please note that you might need to configure VirtualBox to make the service accessible.</p>"},{"location":"asg1/task-vm/#recovery-optional","title":"Recovery (Optional)","text":"<p>In case you encounter an irreparable issue with the VM, simply repeat the aforementioned steps to set up a new one. However, any work previously done will be lost.</p> <p>Creating a snapshot of your virtual machine can be a lifesaver. A snapshot captures the current state of the virtual machine, which you can revert to at any time. This means if something goes wrong, you won't lose all your work - you can simply revert to the snapshot. But that takes up disk space, so use it sparingly.</p> <ol> <li> <p>\"Host\" refers to the machine where VirtualBox is installed and running. For instance, if you run VirtualBox locally on your Windows laptop, the \"host\" refers to Windows. If you are using a MacBook with VirtualBox installed remotely on a server, the \"host\" refers to the remote server rather than your MacBook.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"asg2/","title":"Introduction","text":"<p>Info</p> <p>Please read the general instructions first.</p> <p>The assignment is due 17:59 on 11 Mar 2024. Late submissions will lose 1 mark per hour.</p> <p>If you discover any errors or need any clarification or have any question, please create an issue here.</p>"},{"location":"asg2/#part-a-35-marks","title":"Part A (35 marks)","text":"<p>Info</p> <p>You will be working with Linux kernel version 6.7.0. Please start with the default configuration and make the following modifications:</p> <ul> <li>Activate the <code>DEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT</code> option.</li> <li>Should you require VirtualBox shared folders, ensure that <code>CONFIG_VBOXGUEST</code>   and <code>CONFIG_VBOXSF_FS</code> are enabled in your kernel configuration.   These settings are necessary for the proper functioning of VirtualBox guest   additions, including shared folders support.</li> </ul> <p>Feel free to enable additional features as needed. However, please make sure to save a copy of your kernel configuration and include it in the zip file you submit.</p>"},{"location":"asg2/#task-1-developing-a-kernel-module","title":"Task 1: Developing a Kernel Module","text":"<p>Question 1 (2 marks): Identify the file and line number where the <code>module_init</code> macro is defined for our scenario. Please put your response in the relevant field of the JSON file elaborated below.</p> <p>For example, if it were defined in <code>kernel/sched/core.c</code> at line 6568, you should refer to it as <code>kernel/sched/core.c#L6568</code>.</p> <p>Warning</p> <p>Make sure that you refer to the v6.7.0 version of the kernel source code.</p> <p>Question 2 (2 marks): Why is <code>printk</code> used instead of <code>printf</code> within kernel modules? Please put your response in a file named \"qn2.md\".</p> <p>Question 3 (3 marks): Did you observe the output \"Greetings from xxx\" when you loaded the module? If not, is this string compiled into the module? Provide a brief explanation of how to make the message at the \"DEBUG\" level appear in the kernel log. Please put your response in a file named \"qn3.md\".</p> <p>Question 4 (4 marks): Submit the source code for your kernel module in a file named \"modcpid.c\". This module needs to take two parameters and output the process ID and executable name for the given PID.</p> <ul> <li>Ensure the module compiles without error using the provided Makefile.</li> <li>The module must be able to load and unload without any error.</li> <li>The first line of your source code must indicate the command used for loading   the module with the proper parameters.</li> </ul>"},{"location":"asg2/#task-2-creating-a-new-system-call","title":"Task 2: Creating a New System Call","text":"<p>Question 5 (8 marks): Please provide the patch file for the changes you made to the kernel source code to create the new system call. The patch file should have suffix <code>.patch</code> and adhere to the following requirements:</p> <ul> <li>The patch file must be able to be applied to the v6.7.0 version of the kernel   source code without any errors. If the patch file cannot be applied, you will   receive zero marks for this question.</li> <li>The patched kernel must be able to compile without any errors. If the patched   kernel cannot compile, you will receive zero marks for this question.</li> </ul> <p>Question 6 (4 marks): Please provide the source code for your user-mode program in a C file named <code>getcpid.c</code>. This program should take the PID of a process as input, invoke the new system call you created, and output the PIDs of all its children, one per line. Please ensure that the program compiles without error.</p>"},{"location":"asg2/#task-3-debugging-with-gdb","title":"Task 3: Debugging with GDB","text":"<p>Question 7 (4 marks): Which figure in the ABI document supports your findings on the stack layout? Please put your response in the relevant field of the JSON file.</p> <p>Question 8 (4 marks): Which interrupt line (IRQ) is allocated for this specific interrupt? Please put your response, an integer, in the relevant field of the JSON file.</p> <p>Question 9 (4 marks): What is the name of the <code>clock_event_device</code> that processes the event triggered by this interrupt, as identified by the <code>name</code> field in its structure?</p> <p>Please put the name of the <code>clock_event_device</code> you found in the relevant field of the JSON file.</p>"},{"location":"asg2/#submission-guidelines","title":"Submission Guidelines","text":"<p>Here's the template for your JSON file <code>saq.json</code>, including your responses to Questions 1, 7, 8, and 9. All the values are placeholders and should be replaced with your responses.</p> <pre><code>{\n  \"matric_no\": \"A0123456A\",\n  \"qn1/module_init\": \"/path/to/file#L1234\",\n  \"qn7/stack_layout\": \"Figure X.Y\",\n  \"qn8/irq\": 48,\n  \"qn9/clock_event_device\": \"name-of-the-device\"\n}\n</code></pre> <p>Your submission should be a zip file containing the following files:</p> Filename Description <code>saq.json</code> Your response to Question 1, 7, 8, and 9 in JSON format. Use the template above. <code>qn2.md</code> Your response to Question 2, formatted in Markdown. <code>qn3.md</code> Your response to Question 3, formatted in Markdown. <code>modcpid.c</code> The source code of your kernel module. <code>*.patch</code> The patch file including your implementation of the syscall <code>getcpid</code>. <code>getcpid.c</code> A C program that prints the PIDs of all children of a given process. <code>.config</code> (Optional) Kernel configuration, if you have enabled additional features beyond those specified above. <p>You can verify the contents of your zip file using the <code>unzip -l</code> command. Please note that the files listed above are for illustrative purposes only. The actual files in your submission should not be empty.</p> <pre><code>$ unzip -l asg2.zip\nArchive:  asg2.zip\n  Length      Date    Time    Name\n---------  ---------- -----   ----\n        0  2024-02-11 17:06   saq.json\n        0  2024-02-11 17:06   qn2.md\n        0  2024-02-11 17:06   qn3.md\n        0  2024-02-11 17:06   modcpid.c\n        0  2024-02-11 17:06   xxxxxxxxxx.patch\n        0  2024-02-11 17:06   getcpid.c\n---------                     -------\n        0                     6 files\n</code></pre> <p>Warning</p> <p>Your zip file shall have only one file ending with \".patch\". If you have more than one file ending with \".patch\", you will lose additional marks.</p> <p>Please submit your zip file to Assignment 2 (Part A) on Canvas.</p>"},{"location":"asg2/#part-b-15-marks","title":"Part B (15 marks)","text":"<p>Please complete the quiz Assignment 2 (Part B) on Canvas.</p>"},{"location":"asg2/task-gdb/","title":"Task 3: Debugging with GDB","text":"<p>Info</p> <p>Whenever we mention the \"ABI documentation\", we are referring to the document available at https://refspecs.linuxfoundation.org/elf/x86_64-abi-0.99.pdf. This link is also available on Canvas.</p> <p>Info</p> <p>We assume you have some basic familiarity with GDB. If GDB is completely new to you, consider reviewing these resources from CS:APP beforehand:</p> <ul> <li>Beej's Guide to GDB:   https://beej.us/guide/bggdb/</li> <li>An x86-64 GDB Cheat Sheet:   http://csapp.cs.cmu.edu/3e/docs/gdbnotes-x86-64.txt</li> </ul> <p>For additional support, you might find the following resources helpful:</p> <ul> <li>The Official GDB Manual, Debugging with GDB:   https://sourceware.org/gdb/current/onlinedocs/gdb/</li> </ul>"},{"location":"asg2/task-gdb/#examining-the-stack","title":"Examining the Stack","text":"<p>Write a C program by creating a file named <code>hello.c</code> with the following content:</p> <pre><code>// hello.c\n#include &lt;stdio.h&gt;\n\nint main() {\n    printf(\"Hello, world!\\n\");\n    return 0;\n}\n</code></pre> <p>Compile the program using the command below. This command compiles your program with debug information, which is crucial for debugging. Run the compiled program using GDB with the command:</p> <pre><code>gcc -Og -g -o hello hello.c\ngdb ./hello\n</code></pre> <p>At this point, the program is loaded into GDB but has not started executing. To begin execution up to the start of the <code>main</code> function, use the <code>start</code> command.</p> <pre><code>(gdb) start\n</code></pre> <p>Upon executing the <code>start</code> command, GDB will output something similar to:</p> <pre><code>Temporary breakpoint 1, main () at hello.c:4\n</code></pre> <p>This message indicates that a temporary breakpoint has been set at the beginning of the <code>main</code> function and the program is paused at this point. You can examine the state of the program at this breakpoint.</p> <p>To view the register values at this point, use the <code>info registers</code> command in GDB. This command displays the current values of all registers.</p> <pre><code>(gdb) info registers\n</code></pre> <p>To examine the first 8 values on the stack in hexadecimal format, use the <code>x/8xg $rsp</code> command. This command uses the <code>x</code> command to examine memory and prints 8 quadwords (<code>g</code> stands for giant/quadword) in hexadecimal format from the location pointed to by the stack pointer (<code>rsp</code>).</p> <pre><code>(gdb) x/8xg $rsp\n</code></pre> <p>Refer to the Figure 3.4 in the ABI documentation. Find out the values stored in the registers that are intended for passing the first three arguments to the <code>main</code> function.</p> <p>To exit GDB, use the <code>quit</code> command.</p> <p>Restart the <code>hello</code> program in GDB, this time using the <code>starti</code> command. You'll notice the program pauses at <code>_start</code> instead of <code>main</code>. What is the difference between <code>start</code> and <code>starti</code>?</p> <p>Then, output the first few quadwords on the stack. Among these, you'll identify values that appear to be addresses, not too far from the stack's start. Try printing the content at these addresses using various formats to understand what are they. For help with format specifiers, check the GDB manual's section on Examining Memory.</p> <p>Finally, check the ABI documentation to find the figure or table that supports your observations.</p>"},{"location":"asg2/task-gdb/#attach-gdb-to-kernel-via-qemu","title":"Attach GDB to Kernel via QEMU","text":"<p>Info</p> <p>For more details on QEMU's command-line options and key bindings in the character backend multiplexer, you can refer to the QEMU documentation.</p> <p>Use the following command to start Linux kernel in QEMU. The <code>-s</code> option configures QEMU to listen for a GDB connection on port 1234. The <code>-S</code> option pauses the CPU at startup, providing an opportunity to connect with GDB prior to the kernel's execution. Additionally, KASLR is disabled to simplify the debugging process.</p> <pre><code>qemu-system-x86_64 -s -S -nographic -kernel ./arch/x86/boot/bzImage -append 'console=ttyS0 nokaslr'\n</code></pre> <p>Next, open a new terminal and start GDB. Use the <code>vmlinux</code> file located in the root directory of the kernel source code. This file is an uncompressed kernel image that includes debugging information.</p> <pre><code>gdb vmlinux\n</code></pre> <p>Inside GDB, connect to the GDB server in the active QEMU instance using:</p> <pre><code>(gdb) target remote localhost:1234\n</code></pre> <p>This allows you to set breakpoints, continue execution, and inspect the kernel's state. Let's monitor changes to the <code>jiffies_64</code> variable. Use the <code>watch</code> command:</p> <pre><code>(gdb) watch jiffies_64\n</code></pre> <p>Continue the execution with:</p> <pre><code>(gdb) continue\n</code></pre> <p>The execution will pause when <code>jiffies_64</code> changes. To analyse how <code>jiffies_64</code> is updated, use commands <code>info stack</code> or <code>bt</code> to print the call stack.</p> <pre><code>(gdb) bt\n           &lt;ommited&gt;\n#7  0xffffffff810d2bac in handle_level_irq (desc=0xffff888003860c00) at kernel/irq/chip.c:648\n#8  0xffffffff8102c4c9 in generic_handle_irq_desc (desc=&lt;optimized out&gt;) at ./include/linux/irqdesc.h:161\n#9  handle_irq (regs=&lt;optimized out&gt;, desc=&lt;optimized out&gt;) at arch/x86/kernel/irq.c:238\n#10 __common_interrupt (regs=&lt;optimized out&gt;, vector=48) at arch/x86/kernel/irq.c:257\n#11 0xffffffff81de17a6 in common_interrupt (regs=0xffffffff82803e18, error_code=&lt;optimized out&gt;) at arch/x86/kernel/irq.c:247\nBacktrace stopped: Cannot access memory at address 0xffffc90000004010\n</code></pre> <p>You'll find that the update is triggered by an interrupt, starting from <code>common_interrupt</code>.</p> <p>Explore the kernel source code guided by the stack trace helps understand the <code>jiffies_64</code> update mechanism.</p> <p>Hint</p> <p>When analysing the kernel source code, particularly at <code>generic_handle_irq_desc</code>, you'll notice it invokes a method from <code>struct irq_desc</code>:</p> <pre><code>static inline void generic_handle_irq_desc(struct irq_desc *desc) {\n    desc-&gt;handle_irq(desc);\n}\n</code></pre> <p>The stack trace shows that the <code>handle_level_irq</code> function is called from here. This indicates that <code>handle_level_irq</code> is the method bound to <code>handle_irq</code> in the <code>struct irq_desc</code> instance.</p> <p>The stack trace shows that <code>handle_level_irq</code> is invoked with an argument <code>desc</code>, which is an instance of <code>irq_desc</code> at the memory address <code>0xffff888003860c00</code>, you can inspect this object in GDB:</p> <pre><code>(gdb) print *(struct irq_desc *)0xffff888003860c00\n</code></pre> <p>This GDB command will display the contents of the <code>irq_desc</code> object at the specified address, allowing you to examine its properties and better understand how the kernel handles interrupts and updates variables like <code>jiffies_64</code>.</p> <ul> <li>Which interrupt line (IRQ) is allocated for this specific interrupt?</li> <li>What is the name of the <code>clock_event_device</code> that processes the event   triggered by this interrupt, as identified by the   <code>name</code> field   in its structure?</li> </ul>"},{"location":"asg2/task-module/","title":"Task 1: Developing a Kernel Module","text":"<p>A kernel module is a program that can be dynamically loaded and unloaded into the kernel on demand. This allows for the extension of kernel functionality without requiring the rebuilding of the kernel or system reboot.</p> <p>Numerous functionalities in the Linux kernel are implemented as modules. For instance, device drivers are commonly developed as modules. This modular approach enables the kernel to load only the necessary modules based on the hardware present in the system, effectively maintaining a compact kernel.</p> <p>In this task, we will explore some basic concepts of kernel module development and play with some essential APIs for kernel development.</p>"},{"location":"asg2/task-module/#say-hello-from-the-kernel","title":"Say Hello from the Kernel","text":"<p>Create a directory for your \"Hello World\" module.</p> <p>In the directory, create a file named \"hello.c\" with the following code to implement the \"Hello World\" module.</p> <pre><code>#include &lt;linux/init.h&gt;\n#include &lt;linux/module.h&gt;\n#include &lt;linux/printk.h&gt;\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"cs5250\");\nMODULE_DESCRIPTION(\"A sample kernel module\");\n\nstatic int __init hello_init(void)\n{\n    printk(KERN_NOTICE \"Hello World!\\n\");\n    pr_info(\"Hello, world!\\n\");\n    pr_debug(\"Greetings from %s.\\n\", THIS_MODULE-&gt;name);\n\n    return 0;\n}\n\nstatic void __exit hello_exit(void)\n{\n    pr_info(\"Goodbye world.\\n\");\n}\n\nmodule_init(hello_init);\nmodule_exit(hello_exit);\n</code></pre> <p>Kernel modules must include at least two functions: an initialization function that is called when the module is loaded into the kernel and a cleanup function that is invoked just before the module is removed from the kernel. These functions are registered using the <code>module_init</code> and <code>module_exit</code> macros. Please locate the accurate definition (as used here) of the two macros within the kernel source code.</p> <p>Upon loading the module, the <code>hello_init</code> function is executed, and within it, we print messages using <code>printk</code>. Typically, these messages include a priority level like <code>KERN_NOTICE</code>, <code>KERN_INFO</code> or <code>KERN_DEBUG</code>. In modern conventions, it is recommended to use print macros such as <code>pr_info</code> and <code>pr_debug</code> as alternatives to directly employing <code>printk</code>. These macros wrap around <code>printk</code>, keeping things the same while making code simpler and look nicer by cutting down on repetitive typing.</p> <p>To build the module, you need a Makefile. Please create a file named \"Makefile\" in the same directory as \"hello.c\" with the following content.</p> <pre><code>obj-m += hello.o\n\nall:\n    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules\n\nclean:\n    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean\n</code></pre> <p>Then run <code>make</code> to build the module. You should see a new file named \"hello.ko\" in the directory.</p> <p>To load the module, use the <code>insmod hello.ko</code> command. After loading the module, you can check the kernel log using the <code>dmesg</code> command to see the \"Hello World\" message. Then you can unload the module using the <code>rmmod hello</code> command.</p> <p>Did you see the output \"Greetings from xxx\" when you loaded the module? If not, is this string compiled into the module? How to make the message at the \"DEBUG\" level appear in the kernel log?</p>"},{"location":"asg2/task-module/#passing-arguments-to-a-module","title":"Passing Arguments to a Module","text":"<p>You can pass arguments to a module during its loading process by utilizing the <code>module_param</code> macro for declaring module parameters. Please search for further details on the usage of <code>module_param</code>, and modify the provided program below to declare two module parameters:</p> <ul> <li>A string parameter named \"<code>tag</code>\" with a default value corresponding to your   Matriculation Number.</li> <li>An integer parameter named \"<code>pid</code>\" with a default value of 1.</li> </ul> <pre><code>// sudo insmod hello.ko\n#include &lt;linux/init.h&gt;\n#include &lt;linux/module.h&gt;\n#include &lt;linux/printk.h&gt;\n#include &lt;linux/sched.h&gt;\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"cs5250\");\nMODULE_DESCRIPTION(\"A sample kernel module\");\n\n/* MODIFY THE CODE BELOW TO declare module parameters */\nconst char *tag = \"A01234567A\";\npid_t pid       = 1;\n/* MODIFY THE CODE ABOVE TO declare module parameters */\n\nstatic int __init hello_init(void)\n{\n    pr_debug(\"This is %s speaking.\\n\", tag);\n\n    struct task_struct *task = get_pid_task(find_vpid(pid), PIDTYPE_PID);\n    pr_info(\"%s: [%d] %s\\n\", tag, task-&gt;pid, task-&gt;comm);\n\n    pr_debug(\"Goodbye from %s.\\n\", tag);\n    return 0;\n}\n\nstatic void __exit hello_exit(void)\n{\n    pr_info(\"Goodbye world.\\n\");\n}\n\nmodule_init(hello_init);\nmodule_exit(hello_exit);\n</code></pre> <p>Build the module and load it using the <code>insmod</code> command. You should observe an output in the kernel log similar to the following:</p> <pre><code>A01234567A: [1] systemd\n</code></pre> <p>Provide the <code>insmod</code> command with appropriate arguments to set the \"tag\" to <code>cs5250</code> and the \"pid\" to the PID of any valid process. The module should then print the tag, PID, and the executable name of the process in a similar format.</p> <p>Please modify the first line of your source code to indicate the command used for loading the module with the proper parameters.</p>"},{"location":"asg2/task-syscall/","title":"Task 2: Creating a New System Call","text":"<p>Info</p> <p>For this task, you need to make modifications to the kernel source code and generate a patch. This process should be carried out within the Git repository of the kernel source code, based on version 6.7.0. Please consult the instructions provided in Assignment 1 for detailed guidance on cloning the Git repository.</p> <p>Danger</p> <p>If you are using the course-provided server, kindly perform this task within your VM. At no point should you attempt to install the kernel built by yourself directly in the server.</p>"},{"location":"asg2/task-syscall/#greetings-from-a-new-system-call","title":"Greetings from a New System Call","text":"<p>Generate a file named \"cs5250.c\" within the \"kernel/\" directory in your Linux source tree. Populate the file with the provided content. You have the flexibility to be creative with the printed message, but ensure to include your Matriculation Number.</p> <pre><code>#include &lt;linux/kernel.h&gt;\n#include &lt;linux/syscalls.h&gt;\n\nSYSCALL_DEFINE1(printmsg, int, i)\n{\n    pr_info(\"Hello! This is %d miles away from A0123456A\\n\", i);\n    return 1;\n}\n</code></pre> <p>The <code>SYSCALL_DEFINE1</code> macro is defined in \"syscalls.h\". It expands into the function definition and additional facilities for kernel debugging. The suffix \"1\" signifies that the function takes one argument. For a syscall function with two parameters, use <code>SYSCALL_DEFINE2</code>.</p> <p>Add the line <code>obj-y += cs5250.o</code> to the \"Makefile\" in the \"kernel/\" directory. This ensures that the kernel includes your new program in the kernel image.</p> <p>Find the table of function entries (Hint: it starts with \"syscall\") and append your function as a new entry at the end of the table.</p> <p>Recompile the kernel and boot into the new kernel.</p>"},{"location":"asg2/task-syscall/#invoking-the-new-system-call","title":"Invoking the New System Call","text":"<p>To create a user-mode program that invokes your custom kernel function, here's a sample program template. Make sure to replace <code>&lt;the_index&gt;</code> with the syscall number you were assigned for your custom system call during the previous steps.</p> <pre><code>#include &lt;unistd.h&gt;\n#include &lt;sys/syscall.h&gt;\n\n// Replace &lt;the_index&gt; with your custom system call's actual syscall number.\n#define __NR_printmsg &lt;the_index&gt;\n\nint printmsg(int i) {\n    // Invoke your custom system call using syscall.\n    return syscall(__NR_printmsg, i);\n}\n\nint main(int argc, char **argv) {\n    // Use the custom system call with an example argument, such as 668.\n    printmsg(668);\n    return 0;\n}\n</code></pre> <p>After updating your program with the correct syscall number, compile and run it to trigger your custom system call. Use <code>dmesg</code> to check the outputs and confirm its execution.</p>"},{"location":"asg2/task-syscall/#finding-children","title":"Finding Children","text":"<p>The Linux kernel extensively employs linked lists. The <code>struct task_struct</code> in the Linux kernel includes a <code>children</code> member, a <code>struct list_head</code> representing the head of a linked list of all child processes of a given process.</p> <p>You will implement a new system call, <code>getcpid</code>, and a user-mode program. In \"cs5250.c\", define the <code>getcpid</code> system call that accepts three arguments:</p> <ul> <li>A <code>pid_t</code> representing the PID of the process whose children you wish to retrieve.</li> <li>A pointer to an array of type <code>pid_t*</code> where the PIDs of the children will be stored.</li> <li>A <code>uint32_t</code> indicating the size of the array (in number of elements).</li> </ul> <p>This system call should write the PIDs of the children of the specified process to the provided user space array.</p> <p>For guidance on how the system call should behave, you can look at the interface of <code>getsockname</code>.</p> <p>Additionally, create a user-mode program that uses your custom kernel function. This program should take the PID of a process as input and output the PIDs of all its children, one per line.</p>"},{"location":"asg2/task-syscall/#contribute-to-the-kernel","title":"\"Contribute\" to the Kernel","text":"<p>Please commit your changes and create a patch file<sup>1</sup> that includes all essential changes related to the implementation of the new system call, using <code>git format-patch</code> command. For guidance and reference, check the Git documentation and the Kernel documentation.</p> <p>Please adhere to the following guidelines for your submission:</p> <ol> <li> <p>Make sure your patch can be successfully applied to a clean clone of the    kernel source tree, at version 6.7. If the patch fails to apply, this will    lead to a score of zero for this task.</p> </li> <li> <p>Ensure that the kernel compiles successfully after your patch is applied.    Failure to compile the kernel will also result in a score of zero for this    task.</p> </li> <li> <p>Your patch must contain only the essential changes to the kernel source code    required for implementing the new system call. Any deviation from this    requirement will incur a penalty.</p> </li> <li> <p>If your work results in multiple commits, please be aware that each commit    corresponds to a separate patch file. You are required to combine these    commits into a single commit and then generate a single patch file that    includes all changes.</p> </li> </ol> <ol> <li> <p>This submission format is designed to offer an initial experience in the process of contributing to the Linux kernel. In future contributions to the Linux kernel, it will be imperative to generate a patch file including your changes and submit it for review to the community's mailing list. The intention is not to challenge your proficiency in using Git, and it's not divergent from the primary goals of this course.\u00a0\u21a9</p> </li> </ol>"},{"location":"asg3/","title":"Introduction","text":"<p>Info</p> <p>Please read the general instructions first.</p> <p>The assignment is due 17:59 on 1 Apr 2024. Late submissions will lose 1 mark per hour.</p> <p>If you discover any errors or need any clarification or have any question, please create an issue here.</p>"},{"location":"asg3/#part-a-35-marks","title":"Part A (35 marks)","text":"<p>Note</p> <ul> <li>You will be working with Linux kernel version 6.7.0.</li> <li> <p>Start with the default configuration and apply the following updates:</p> <ol> <li>Enable the following features in your kernel configuration:<ul> <li><code>CONFIG_DEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT</code></li> </ul> </li> <li>If you require VirtualBox shared folders, ensure the following options    are enabled in your kernel configuration:<ul> <li><code>CONFIG_VBOXGUEST</code></li> <li><code>CONFIG_VBOXSF_FS</code></li> </ul> </li> <li>Additional features can be enabled as necessary.    However, ensure to preserve a copy of your kernel configuration and    include it in the submitted zip file.</li> </ol> </li> </ul>"},{"location":"asg3/#task-1-hook-system-calls-with-kprobes","title":"Task 1: Hook System Calls with KProbes","text":"<p>Question 1 (2 marks): What is the name of the system call that the game uses to keep track of time?</p> <p>Please submit your response as a field in the YAML file (specified below).</p> <p>Question 2 (2 marks): Give the complete command to run <code>strace</code> so that:</p> <ul> <li>The output is written to a file.</li> <li>Only the system call that the game uses to keep track of time is shown.</li> <li>It's fine if there are some other outputs not related to system calls, e.g.,   information about signals or exit status.</li> </ul> <p>Please submit your response as a field in the YAML file (specified below).</p> <p>Question 3 (5 marks): At line 23 of the sample kernel module, the <code>kprobe</code> is set to hook the <code>regs = (struct pt_regs *)regs-&gt;di</code>. Why do we need such an indirection to get the arguments of the system call? Hint: [How Does a Kprobe Work?] [Notes on System Entry]</p> <p>Please write your response in a Markdown file.</p> <p>Question 4 (2 marks): What is the GDB command to print the entry in the syscall table for the system call you identified in the previous question?</p> <p>Please submit your response as a field in the YAML file (specified below).</p> <p>Question 5 (3 marks): What is the problem with the address of the system call service routine? How can you fix this problem?</p> <p>Please write your response in a Markdown file.</p> <p>Question 6 (6 marks): Please provide the source code of the modified kernel module. Check the task description for the requirements of the program.</p> <p>Please submit your code in a file named <code>hook.c</code>.</p>"},{"location":"asg3/#task-2-memory-manipulation-in-tetris-game","title":"Task 2: Memory Manipulation in Tetris Game","text":"<p>Question 7 (5 marks): In which memory regions is it likely that the score is stored?</p> <ol> <li>Provide a complete copy of the output of <code>/proc/[pid]/maps</code> for the <code>tetris</code>    process.</li> <li>List the memory regions that you believe are probable candidates for storing    the score.</li> <li>Explain your rationale for why these memory regions are likely to contain the    score.</li> </ol> <p>Please write your response in a Markdown file.</p> <p>Question 8 (6 marks): Please submit the source code of the C program that hacks the score in the <code>tetris</code> game. Check the task description for the requirements of the program.</p> <p>Please submit your code in a file named <code>hack-tetris.c</code> or <code>hack-tetris.py</code>, depending on the language you choose.</p> <p>Question 9 (4 marks): Please discuss security concern with a LLM such as ChatGPT. Ask if there are any methods to prevent such unwanted actions. Evaluate the provided response for its effectiveness. If multiple solutions are suggested, choose ONLY one of them to discuss.</p> <p>Please write your response in a Markdown file.</p>"},{"location":"asg3/#submission-guidelines","title":"Submission Guidelines","text":"<p>Here's the template for your YAML file <code>saq.yml</code>, including your responses to Questions 1, 2 and 4. All the values are placeholders and should be replaced with your responses.</p> <pre><code>matric_no: \"A0123456A\"\nqn1_syscall: \"...\"\nqn2_strace: \"strace ...\"\nqn4_gdb: \"print ...\"\n</code></pre> <p>Your submission should be a zip file containing the following files:</p> Filename Description <code>saq.yml</code> Your response to Question 1, 2 and 4, use the template above. <code>qn3.md</code> Your response to Question 3 in Markdown format. <code>qn5.md</code> Your response to Question 5 in Markdown format. <code>hook.c</code> Source code of the modified kernel module. <code>qn7.md</code> Your response to Question 7 in Markdown format. <code>hack-tetris.c</code> or <code>hack-tetris.py</code> Source code of the program hacking the score. <code>qn9.md</code> Your response to Question 9 in Markdown format. <code>.config</code> (Optional) Kernel configuration, if you have enabled additional features beyond those specified. <p>Please submit your zip file to Assignment 3 (Part A) on Canvas.</p>"},{"location":"asg3/#part-b-15-marks","title":"Part B (15 marks)","text":"<p>Please complete the quiz Assignment 3 (Part B) on Canvas.</p>"},{"location":"asg3/task-kprobe/","title":"Task 1: Hook System Calls with KProbes","text":"<p>Note</p> <ul> <li>Download the executable <code>tetris</code> from the link below:   Tetris Executable</li> <li>The SHA-256 hash of the file is provided below for verification:   You can regenerate the hash using the <code>sha256sum</code> command and compare it   manually, or use the provided <code>tetris.sha256</code> file to verify the hash.   <pre><code>$ sha256sum tetris\n22cab9532516f63a6d3541ab7d9fd0dcd437881e0293670679e06c300ab9c3b5  tetris\n$ sha256sum -c tetris.sha256\ntetris: OK\n</code></pre></li> <li>The executable is a statically linked 64-bit ELF binary.   It should execute without issues on your Ubuntu system.   If any problems arise, please report them   here.</li> </ul> <p>Before beginning, execute the <code>tetris</code> binary and get familiarized with the game.</p>"},{"location":"asg3/task-kprobe/#how-time-flies","title":"How Time Flies","text":"<p>In this game, the bricks fall from the top of the screen by one row at a specific time interval. As you can imagine, there should be some mechanism to keep track of time and trigger the movement of the bricks. This can be achieved in two general ways:</p> <ul> <li>One approach is to use a loop, where the program sleeps for a specific time   interval and then moves the bricks. In this method, the program invokes a   <code>sleep</code> system call to pause execution for the desired interval.</li> <li>Another approach involves using a timer to prompt the movement of the bricks.   In this method, the program sets up a timer and registers a callback function   to execute when the timer expires.</li> </ul> <p>Since both methods require the use of system calls, let's use <code>strace</code> to observe how the game tracks time.</p> <p>You can get an initial idea of <code>strace</code> by running the following command:</p> <pre><code>strace cat /dev/null\n</code></pre> <p>You should see a list of system calls made by the <code>cat</code> command. The arguments and return values of the system calls are also printed.</p> <p>However, if you run <code>strace ./tetris</code> directly, the output will be corrupted due to interleaved output both from the game and <code>strace</code>. So you should write the output of <code>strace</code> to a file and later inspect it.</p> <pre><code>strace -o &lt;filename&gt; ./tetris\n</code></pre> <p>Give a filename of your choice to the <code>-o</code> option, execute the command, and enjoy the game for a while. Then press <code>q</code> to quit the game and inspect the output file.</p> <p>Question</p> <p>What is the name of the system call that the game uses to keep track of time?</p> <p>Please read the man page of the system call or ask ChatGPT if you need to learn how to use it. Write a small program to demonstrate the use of the system call. You will use this program later.</p> <p>The <code>strace</code> outputs many system calls. To facilitate the analysis, some flag can be used to filter the output. Read the man page of <code>strace</code> to find the flag that can be used to filter the output of <code>strace</code> to only show the system call you identified in the previous question.</p> <p>Question</p> <p>Give the complete command to run <code>strace</code> so that:</p> <ul> <li>The output is written to a file.</li> <li>Only the system call that the game uses to keep track of time is shown.</li> <li>It's fine if there are some other outputs not related to system calls,   e.g., information about signals or exit status.</li> </ul>"},{"location":"asg3/task-kprobe/#wait-its-too-fast","title":"Wait! It's Too fast!","text":"<p>Now that you have identified the system call used by the game to keep track of time, let's try to slow down the passage of time, giving you more opportunities to make decisions.</p> <p>To achieve this, we'll employ a kernel feature known as KProbes. KProbes allows inserting a probe at a specific kernel address and registering a callback function to be invoked when the probe is hit. This callback function can modify the arguments and return value of the probed function, or even bypass its execution.</p>"},{"location":"asg3/task-kprobe/#a-first-glance-at-kprobes","title":"A First Glance at KProbes","text":"<p>To use KProbes, you'll need to develop a kernel module. Here's a simple example of a kernel module using KProbes to intercept the <code>__do_sys_ni_syscall</code> system call and print the arguments passed to it.</p> <p>Lines 26-28 of the code implement a simple filter, ensuring the probe triggers only when the <code>current</code> process has a <code>comm</code> field matching the specified string argument <code>comm</code>. When loading the module, you must provide an appropriate value to the <code>comm</code> argument to ensure the probe triggers only when the intended program is running.</p> <p>Here's a user program that invokes the <code>__do_sys_ni_syscall</code> system call.</p> <p>After building and installing the kernel module, execute the user program. Subsequently, inspect the kernel log to observe the output of the kernel module. You will find the arguments passed to the <code>__do_sys_ni_syscall</code> system call there.</p> <pre><code>hook: --- [[ Module loaded ]] ---\nhook: pre_handler: __do_sys_ni_syscall@000000009e4e93a8\nhook: triggered in test [29832]\nhook: regs-&gt;di  = 0x10\nhook: regs-&gt;si  = 0x20\nhook: regs-&gt;dx  = 0x30\nhook: regs-&gt;r10 = 0x40\nhook: regs-&gt;r8  = 0x50\nhook: regs-&gt;r9  = 0x60\nhook: --- [[ Module unloaded ]] ---\n</code></pre> <p>Question</p> <p>At line 33 of the kernel module, we have <code>regs = (struct pt_regs *)regs-&gt;di</code>. Why do we need such an indirection to get the arguments of the system call?</p> <p>Hint:</p> <ul> <li>How Does a Kprobe Work?</li> <li>Notes on System Entry.pdf</li> </ul>"},{"location":"asg3/task-kprobe/#first-attempt","title":"First Attempt","text":"<p>To hook the system call, you need to find the symbol name of the service routine implementing the system call. You've done this in Pop Quiz 6, and you can do it again. However, with the <code>vmlinux</code> file available, you can use <code>gdb</code> to find the symbol name of the service routine.</p> <pre><code>$ gdb vmlinux\n\n&lt;some output omitted here&gt;\n\n(gdb) print sys_call_table\n$1 = {...}\n</code></pre> <p>This command prints the contents of the <code>sys_call_table</code> variable, which is a lengthy array of function pointers. To locate the symbol name of the service routine, you can look up the syscall table to find the syscall number of the system call and then print only that entry in the syscall table.</p> <p>Question</p> <p>What is the GDB command to print the entry in the syscall table for the system call you identified in the previous question?</p> <p>Having identified the symbol name of the service routine, you can proceed to modify the kernel module to hook the desired system call. After modifying the kernel module, build it and load it into the kernel. In a previous step, you wrote a small program to demonstrate the use of the system call. Now, execute the program and review the kernel log to observe the output.</p> <p>Take note of the address of the system call service routine. You may find that it does not fall within the region of the \"kernel text\", as indicated in the memory layout documentation. Why is this the case? How can you fix this problem?</p> <p>Question</p> <p>What is the problem with the address of the system call service routine? How can you fix this problem?</p> <p>The subsequent step involves writing code to extend the duration before the next movement of the bricks. This can be accomplished by modifying the arguments of the system call. However, the important argument is passed as a pointer, pointing to a user space address. Directly changing the value in user space might trigger the game's cheat detection mechanism, leading it to refuse execution. Therefore, it would be better if we modify the value in kernel space. However, the original service routine assumes that the pointer points to a valid user space address. If it turns out that the pointer points to an address in kernel space, the original service routine could crash. This presents a challenging scenario!</p>"},{"location":"asg3/task-kprobe/#second-attempt","title":"Second Attempt","text":"<p>Let's find a workaround. Find the definition of the system call in the kernel source code and observe how it handles the pointer argument. Can you identify another function to hook where the important argument is already in kernel space?</p> <p>Modify the kernel module to:</p> <ul> <li>Hook the new function you found, simplifying the task.</li> <li>Increment the duration by one second.</li> <li>Adjust the <code>MODULE_AUTHOR</code> to your Matriculation Number.</li> </ul> <p>After loading the kernel module, run the game and observe if the time flows slower.</p> <p>Question</p> <p>Please provide the source code of the modified kernel module.</p>"},{"location":"asg3/task-memhack/","title":"Task 2: Memory Manipulation in Tetris Game","text":"<p>Note</p> <p>In this task, you'll be using the same <code>tetris</code> binary as in Task 1.</p> <p>The game might not hold much appeal, but I'm eager to impress my friends with an incredibly high score. Let's surprise them by modifying the score in the game.</p> <p>The score is stored as a <code>int32_t</code> variable in memory. We'll locate the address of the score and update it to a large number.</p>"},{"location":"asg3/task-memhack/#memory-regions","title":"Memory Regions","text":"<p>In order to modify the score, we need to find the address of the score in the <code>tetris</code> process.</p> <p>The memory regions mapped to a process can be found in <code>/proc/[pid]/maps</code>. For instance, to view the memory regions of the <code>bash</code> process:</p> <pre><code>$ pgrep bash\n769525\n$ cat /proc/769525/maps\n&lt;output omitted here&gt;\n</code></pre> <p>Please check the manual page of <code>proc</code> for the meaning of the columns.</p> <p>Run the <code>tetris</code> game and pause it. Find its process ID using the <code>ps</code> or <code>pgrep</code> command. Then, print the memory regions of the <code>tetris</code> process.</p> <p>Question</p> <p>In which memory regions is it likely that the score is stored?</p> <ol> <li>Provide a complete copy of the output of <code>/proc/[pid]/maps</code> for the    <code>tetris</code> process.</li> <li>List the memory regions that you believe are probable candidates for    storing the score.</li> <li>Explain your rationale for why these memory regions are likely to    contain the score.</li> </ol>"},{"location":"asg3/task-memhack/#find-the-address-of-the-score","title":"Find the Address of the Score","text":"<p>Merely identifying suspicious memory regions isn't sufficient; pinpointing the exact address of the score in the <code>tetris</code> process is necessary. To find the exact address of the score in the <code>tetris</code> process, we can play the game briefly, pause it, and then search through these regions for the score value. If a word in a memory region matches the score value, it's likely where the score is stored. This involves digging into the <code>tetris</code> process's virtual memory to gather the necessary information.</p> <p>Under procfs, there's a file <code>/proc/[pid]/mem</code> that allows you to read and write to the virtual memory of a process. Please refer to the man page of <code>proc</code> and read the section about <code>/proc/[pid]/mem</code>.</p> <p>Tip</p> <p>No need to worry about permission issues in this task. You can use <code>sudo</code> to read and write to <code>/proc/[pid]/mem</code>.</p> <p>Here's a demo to help you understand how to hack into the virtual memory of a process via <code>/proc/[pid]/mem</code>.</p> <p>Please write a program in C or Python to locate the address of the score in the <code>tetris</code> process. The program should accept a single command-line argument, which is the process ID of the <code>tetris</code> process.</p> <p>The program should first read the <code>maps</code> file of the <code>tetris</code> process to determine the potential memory ranges where the score might be stored. Then, it should read the score value from stdin and scan through the identified memory regions to locate the score value. If it finds a memory location holding the score value, it should print out the address of that memory location.</p> <p>Tip</p> <p>The actual pathname of the executed command in a process can be found by reading the symbolic link <code>/proc/[pid]/exe</code>.</p> <pre><code>$ ls -al /proc/$$/exe\nlrwxrwxrwx 1 shenjm shenjm 0 Mar 13 00:16 /proc/73799/exe -&gt; /usr/bin/zsh*\n</code></pre> <p>Here is an example of how to use the <code>readlink</code> function to read the symbolic link.</p> <p>It's possible that within these regions, there are multiple words containing the same value as the score. To eliminate false positives, you can continue playing the game and pause it again to observe how these words change. If you find memory locations that don't change as expected when the score updates, you can exclude them from consideration and finally find the actual address of the score.</p>"},{"location":"asg3/task-memhack/#hack-the-score","title":"Hack the Score","text":"<p>Now that you have determined the address of the score, you can proceed to modify it to a larger number, such as 1000000.</p> <p>Please update your program as follows:</p> <ol> <li>Accept one additional command-line argument: the new score.</li> <li>Once the address of the score is found, write the new score to that memory    location.</li> </ol> <p>Finally, you should be able to perform the hacking using a single command:</p> <pre><code>$ sudo ./hack-tetris &lt;pid&gt; &lt;target-score&gt;\n</code></pre> <p>Question</p> <p>Please submit the source code of the program written in either C or Python. If you choose Python, ensure that the first line of your program is <code>#!/usr/bin/env python3</code>.</p> <p>Warning</p> <p>Please note: any compilation errors, syntax errors, or runtime errors will result in a score of 0 for this task.</p> <p>You should probe the address of the score in your program interactively. It's not allowed to hardcode the address of the score in your program. A different victim program will be used to test your program, so the address will be different from the one in this tetris game.</p>"},{"location":"asg3/task-memhack/#im-so-scared","title":"I'm So Scared!","text":"<p>In this task, we demonstrated how a root user can read and write to the virtual memory of a process running on the system, posing a security risk. If you are using a shared system like the SoC Compute Cluster, the system administrator might potentially access your process and extract sensitive runtime information as well.</p> <p>Question</p> <p>Please discuss security concern with a LLM such as ChatGPT. Ask if there are any methods to prevent such unwanted actions. Evaluate the provided response for its effectiveness. If multiple solutions are suggested, choose only ONE of them to discuss.</p>"},{"location":"asg3/task-sched/","title":"Optional: Understanding the Linux Scheduler","text":"<p>Warning</p> <p>This task is for your self-exploration only. You are not required to submit any answers for this task. It is not graded and does not contribute to your final mark.</p> <p>Note</p> <p>You will be working with Linux kernel version 6.7.0. Download the kernel configuration file from here. Since this kernel is intended for use with QEMU only, support for VirtualBox shared folders, etc., is not required.</p> <p>Ensure the downloaded configuration file is placed in the root directory of the kernel source tree and rename it to <code>.config</code>. Then proceed to build the kernel using the command <code>make -j$(nproc)</code>.</p> <p>After that, execute the following command to generate the <code>vmlinux-gdb.py</code> file:</p> <pre><code>make scripts_gdb\n</code></pre>"},{"location":"asg3/task-sched/#code-browsing","title":"Code Browsing","text":"<p>There are several tools available to assist you in navigating the kernel source code. You may find this page helpful for an overview of these tools.</p> <p>For this task, I recommend using <code>clangd</code> in conjunction with <code>VSCode</code>. <code>clangd</code> offers the advantage of interpreting the kernel's build configuration, providing relatively accurate code navigation features. When combined with <code>VSCode</code>, you can easily navigate through the kernel source code. Additionally, code disabled by macros in the kernel configuration file will appear greyed out, allowing you to focus on the active part of the code.</p> <p>However, if you prefer using other editors or IDEs, you are free to do so. You can refer to this page for a list of other editors/IDEs compatible with <code>clangd</code>.</p> <p>Below is a brief guide to setting up <code>clangd</code> and <code>VSCode</code>. For more detailed instructions, you can search the web or ask ChatGPT for assistance:</p> <ol> <li>Build the kernel on your Linux machine as usual.</li> <li>Run <code>./scripts/clang-tools/gen_compile_commands.py</code> in the kernel source tree    to generate the <code>compile_commands.json</code> file.</li> <li>Install VSCode on your local machine.</li> <li>Install the \"remote-ssh\" extension in VSCode.</li> <li>Connect to the VM using the \"remote-ssh\" extension in VSCode.</li> <li>Install the \"clangd\" extension from the Extension marketplace in the VM.</li> <li>Use \"open folder\" to open the kernel source tree in VSCode.</li> <li>Open a C file within the kernel source tree. If <code>clangd</code> is not installed,    you will receive a prompt at the bottom-right corner of the window asking you    to install <code>clangd</code>. Click \"Install\" to proceed.</li> </ol> <p>Note: If you have the official \"C/C++\" extension installed, you may need to disable it to prevent conflicts with <code>clangd</code>.</p> <p>Once set up, you can open the file <code>kernel/sched/fair.c</code> at line 13073, where the object for the fair scheduling class is defined. You will notice that many fields are greyed out, indicating that they are disabled by macros in the kernel configuration file.</p> <p>In the object, you will see several functions wrapped between <code>#ifdef CONFIG_SMP</code> and <code>#endif</code>, which are disabled by the <code>CONFIG_SMP</code> macro.</p> <p>Question</p> <p>When <code>CONFIG_SMP</code> is disabled, what feature is lost? How does this simplification aid in analyzing the scheduler?</p>"},{"location":"asg3/task-sched/#attaching-gdb-to-the-kernel","title":"Attaching GDB to the Kernel","text":"<p>You've already learned how to attach GDB to the kernel via QEMU in the previous assignment.</p> <p>Below is a Makefile to automate the process of attaching GDB to the kernel:</p> <pre><code>KERNEL_DIR = ../linux-6.7\n\nbzImage = $(KERNEL_DIR)/arch/x86/boot/bzImage\nvmlinux = $(KERNEL_DIR)/vmlinux\n\nqemu:\n    qemu-system-x86_64 \\\n        -s -S \\\n        -nographic \\\n        -kernel $(bzImage) \\\n        -append \"nokaslr console=ttyS0\"\n\ngdb: vmlinux-gdb.py\n    gdb $(vmlinux) -x gdbinit\n\nvmlinux-gdb.py:\n    ln -s $(KERNEL_DIR)/scripts/gdb/vmlinux-gdb.py .\n</code></pre> <p>Make sure to update the <code>KERNEL_DIR</code> variable to the path of your kernel source tree.</p> <p>The <code>gdbinit</code> file contains the following commands:</p> <pre><code>define hook-quit\n    kill\nend\n\ntarget remote localhost:1234\n</code></pre> <p>You can now use <code>make qemu</code> to start the QEMU instance and execute <code>make gdb</code> in another terminal to attach GDB to the QEMU instance. When GDB is launched, it will execute the commands specified in the <code>gdbinit</code>. These commands include a hook to terminate QEMU when GDB is exited and establish a connection between GDB and the QEMU instance.</p> <p>Should you encounter a warning indicating \"auto-loading has been declined,\" it suggests that the script <code>vmlinux-gdb.py</code> provided by the kernel was not loaded successfully. This script offers a range of commands to streamline kernel debugging. For more information regarding this script, please refer to this page.</p> <p>Follow the instructions provided in the warning message to resolve the warning.</p>"},{"location":"asg3/task-sched/#drawing-a-call-graph","title":"Drawing a Call Graph","text":"<p>To gain a better understanding of how things work, we can create a call graph for a specific function of interest.</p> <p>For instance, if we want to understand how the <code>__schedule</code> function is invoked, we can follow these steps:</p> <ol> <li>Launch the kernel and attach GDB to it as described previously.</li> <li>Set a breakpoint at the beginning of the <code>__schedule</code> function.</li> <li>Execute the <code>continue</code> command to allow the kernel to run.</li> <li>When the breakpoint is hit, execute the <code>bt</code> command to print the call stack,    revealing the call path to the <code>__schedule</code> function.</li> <li>Repeat the process several times to collect multiple call paths to the    <code>__schedule</code> function.</li> <li>Use a Python script to parse the collected call paths.</li> </ol> <p>Here are some helpful tips:</p> <ul> <li>Use the   \"logging\"   feature of GDB to dump the outputs to a file.</li> <li>Define a   \"hook\" in   GDB so that it automatically executes the <code>backtrace</code> command when the   breakpoint is hit.</li> </ul> <p>Then by setting the breakpoint and repeating the <code>continue</code> command, you can collect the call paths. Once the call paths are collected, you can use a Python script to parse them.</p> <p>The provided Python script prints a dot script. You can use Graphviz to generate the diagram from the dot script using the following command:</p> <pre><code>python3 draw-call-graph.py gdb.__schedule.txt | dot -Tsvg -o schedule.svg\n</code></pre> <p>You can replace the <code>svg</code> in the command with other formats such as <code>png</code> or <code>pdf</code> to generate the diagram in different formats. Additionally, feel free to modify the provided script to meet your specific requirements, or explore alternative methods to generate the call graph.</p> <p>Here's an example of the call graph for the <code>__schedule</code> function:</p> <p></p> <p>Question</p> <p>Please create a call graph illustrating the invocation of the <code>place_entity</code> function.</p> <p>Ensure the diagram is generated in PDF format and include it in your submission.</p>"},{"location":"asg3/task-sched/#inspecting-the-fair-scheduler","title":"Inspecting the Fair Scheduler","text":"<p>In this task, we will concentrate on a subset of methods utilized within the fair scheduler. These methods are as follows:</p> <pre><code>DEFINE_SCHED_CLASS(fair) = {\n    .enqueue_task   = enqueue_task_fair,\n    .dequeue_task   = dequeue_task_fair,\n    .yield_task     = yield_task_fair,\n    .wakeup_preempt = check_preempt_wakeup_fair,\n    .pick_next_task = __pick_next_task_fair,\n    .put_prev_task  = put_prev_task_fair,\n    .set_next_task  = set_next_task_fair,\n    .task_tick      = task_tick_fair,\n    .task_fork      = task_fork_fair,\n};\n</code></pre> <p>This setup reflects an object-oriented programming approach in C.</p> <p>Please analyse the provided methods within the setup. Determine the functionality of each method and identify when they are typically called. You can consult with ChatGPT or Copilot on this.</p> <p>After analysing the call graph generated in the previous part, it's evident that the <code>place_entity</code> function is invoked from 2/3 distinct paths:</p> <ol> <li><code>kernel_clone</code> \u2192<ul> <li><code>copy_process</code> \u2192 <code>task_fork_fair</code> \u2192 <code>place_entity</code></li> <li><code>wake_up_new_task</code> \u2192 <code>activate_task</code> \u2192 <code>enqueue_task_fair</code> \u2192 <code>place_entity</code></li> </ul> </li> <li><code>try_to_wake_up</code> \u2192 <code>activate_task</code> \u2192 <code>enqueue_task_fair</code> \u2192 <code>place_entity</code></li> </ol> <p>Path 1 primarily deals with the creation of a new task, while Path 2 focuses on awakening a previously sleeping task.</p> <p>Please review the source code of <code>place_entity</code> to discern how it behaves differently between the two types of incoming tasks during placement.</p> <p>Question</p> <p>Please provide a brief explanation of the differences in the behaviour of <code>place_entity</code> between the two types of incoming tasks.</p> <p>Another observation is that <code>place_entity</code> is called twice for each new task created. Is this a bug or a feature? Please provide a brief explanation.</p> <p>Hint:</p> <ul> <li>Use the techniques we've covered to help figure out the behaviour.</li> <li>When you use GDB to debug the kernel, you can use <code>$lx_current()</code> to get the   current task and <code>$lx_per_cpu(\"runqueues\")</code> to get the runqueues. These are   useful helpers provided by the <code>vmlinux-gdb.py</code> script.</li> </ul> <p>Question</p> <p>Is calling <code>place_entity</code> twice for each new task created a bug or a feature? Please provide a brief explanation.</p> <p>Hint: https://lore.kernel.org/all/20231023154319.102437-1-daniel.m.jordan@oracle.com/T/#u</p>"},{"location":"asg4/","title":"Introduction","text":"<p>Info</p> <p>Please read the general instructions first.</p> <p>The assignment is due 17:59 on 22 Apr 2024. Late submissions will lose 1 mark per hour.</p> <p>If you discover any errors or need any clarification or have any question, please create an issue here.</p>"},{"location":"asg4/#part-a-35-marks","title":"Part A (35 marks)","text":"<p>Note</p> <p>Please accept the assignment on GitHub Classroom first. The invitation link is available on Canvas.</p>"},{"location":"asg4/#task-1-character-device-driver","title":"Task 1: Character Device Driver","text":"<p>Question 1 (6 marks)</p> <p>Please explain, in detail, how the <code>container_of</code> macro works in the <code>onebyte_open</code> function, and how it's used to retrieve the <code>onebyte_data</code> structure.</p> <p>Additionally, explain why the <code>onebyte_data</code> structure is stored as the private data of the file instead of being stored as a global variable?</p> <p>Question 2 (2 marks)</p> <p>Provide the exact <code>mknod</code> command you used to create the device file.</p>"},{"location":"asg4/#task-2-pci-device","title":"Task 2: PCI Device","text":"<p>Question 3 (4 marks)</p> <p>Why can't we read from the file <code>resource0</code>?</p> <p>Hint:</p> <ul> <li>According to the   documentation, <code>rw</code>   access is allowed for <code>IORESOURCE_IO</code> regions only in files named   <code>resource0..N</code>.</li> <li>You should refer to the information from the configuration space.</li> </ul> <p>Question 4 (5 marks)</p> <p>Please finish the implementation under the directory <code>task2-mmap/</code> in the repository.</p>"},{"location":"asg4/#task-3-interrupt-handler","title":"Task 3: Interrupt handler","text":"<p>Question 5 (18 marks)</p> <p>Please finish the implementation under the directory <code>task3-factorial/</code> in the repository.</p>"},{"location":"asg4/#submission-guidelines","title":"Submission Guidelines","text":"<p>Please accept the assignment on GitHub Classroom first. The invitation link is available on Canvas. Then, proceed to complete the tasks in the repository and push your changes accordingly. I'll pull your work from the repository after the deadline.</p> <p>Please note the following instructions:</p> <ol> <li> <p>The deadline posted on GitHub is the hard deadline \u2014 you'll lose write access    to the repository after that time. However, late penalties will apply    starting from the due date on Canvas.</p> </li> <li> <p>I will evaluate two versions of your code for grading: (1) the last commit    before the due date on Canvas and (2) the last commit pushed to the    repository with late penalties applied. The higher grade of the two versions    will be your final grade for this part.</p> </li> <li> <p>Ensure that your code can be successfully built and that modules can be    loaded into the kernel. Failure to build or load will result in a mark of 0.</p> </li> <li> <p>Coding style matters.</p> <ul> <li>Inside the repository, there's a file named <code>.clang-format</code> which sets    rules for how your code should look.</li> <li>You can use a tool called <code>clang-format</code> to automatically format your code    according to these rules.</li> <li>Feel free to adjust the <code>.clang-format</code> file to your liking, but whatever    changes you make, your final submission needs to follow those rules that    you set.</li> <li>I'll run a check on your code using <code>clang-format --dry-run --Werror</code>. This    includes both C source code files and header files. If <code>clang-format</code> has    any complaints with your code, you'll lose 1 mark per file.</li> <li>It's recommended to use <code>clang-format</code> version 18, but you can also use    version 14, which comes with Ubuntu 22.04.</li> </ul> </li> <li> <p>Only push essential files to the repository.</p> <ul> <li>Do not include binaries, object files, or any other generated files from    your source code.</li> <li>Make sure to properly utilize the <code>.gitignore</code> file to exclude    inappropriate files from being pushed to the repository.</li> <li>If your repository is messy or contains any unnecessary files, there will    be a one-time penalty of 2 marks.</li> </ul> </li> </ol> <p>The repository contains the following files or directories:</p> Filename Description <code>/qn1.md</code> Your response to Question 1 in Markdown format. <code>/qn2.md</code> Your response to Question 2 in Markdown format. <code>/qn3.md</code> Your response to Question 3 in Markdown format. <code>/task2-mmap/*</code> Your code operating the PCI device using <code>mmap</code>. <code>/task3-factorial/*</code> Your device driver implementing the factorial calculation. <p>Please, besides, fill in your GitHub username in the Assignment 4 (Part A) on Canvas.</p>"},{"location":"asg4/#part-b-15-marks","title":"Part B (15 marks)","text":"<p>Please complete the quiz Assignment 4 (Part B) on Canvas.</p>"},{"location":"asg4/task-chardev/","title":"Task 1: Character Device Driver","text":""},{"location":"asg4/task-chardev/#overview","title":"Overview","text":"<p>In Linux, hardware devices are presented to user space as device files, which can be accessed using standard file I/O operations. These device files reside in the \"/dev\" directory and are backed by device drivers, kernel components that interact with the hardware device. Typically, device drivers are implemented as modules. System calls like open, read, write, close, lseek, mmap, etc., made to these device files are routed to the corresponding device driver for handling.</p> <p>There exist two primary types of device files: character device files (chrdev) and block device files (blkdev). These types are differentiated by the speed, volume, and method of data transfer between the device and the system.</p> <p>A character device file represents a slower device that transfers data in streams of bytes, examples include keyboards, mice, serial ports, or terminals. Managing these devices is relatively simple since they don't demand extremely high performance.</p> <p>In contrast, a block device file represents a faster device that transfers data in fixed-size blocks, such as hard disks or flash drives. Block devices typically offer higher speeds compared to character devices, and their performance is critical. So Linux provides a different set of APIs for interacting with block devices, allowing for common support features like caching, buffering, and I/O scheduling to be implemented.</p> <p>To identify device drivers in your kernel, use the command <code>ls -l /dev</code> and examine the information in each column. The first letter in each line indicates if it's a char device (represented as \"c\") or a block device (represented as \"b\"). The major and minor numbers are also displayed. The major number identifies the specific driver associated with the device. It is used by the kernel to route system calls for the device to the appropriate driver. The minor number is used by the kernel to determine the exact device being referred to. For example, in a disk driver, the minor number might specify a partition on the disk.</p> <pre><code>$ ls -l /dev/sd*\nbrw-rw---- 1 root disk 8, 0 Feb 20 16:36 /dev/sda\nbrw-rw---- 1 root disk 8, 1 Feb 20 16:36 /dev/sda1\nbrw-rw---- 1 root disk 8, 2 Feb 20 16:36 /dev/sda2\n</code></pre>"},{"location":"asg4/task-chardev/#onebyte-character-device","title":"Onebyte Character Device","text":"<p>In this task, we will see a character device driver that exposes the \"onebyte\" hardware device to user space as a character device file. \"onebyte\" can store only one byte, backed by a single byte of memory.</p> <ul> <li>When the driver is loaded, \"onebyte\" is initialized to -1.</li> <li>When the device is read, the byte is returned to the user.</li> <li>When the device is written, the byte is overwritten with the new value.</li> </ul> <p>It is both \"global\" and \"persistent\", meaning that multiple file descriptors can access the data inside, and its data remains available and unchanged even when the device is closed and reopened. By exposing it as a character device file, it can be accessed using standard file I/O operations and tested with shell commands such as cat, echo, and I/O redirection.</p> <p>Before using the character device, it needs to be registered. The <code>file_operations</code> structure needs to be set up, within which, we can define the behaviour of the device by implementing the <code>open</code>, <code>release</code>, <code>read</code> and <code>write</code> functions.</p> <p>Please refer to the following code snippet for the implementation of the onebyte character device driver.</p> <p>Question</p> <p>Please explain, in detail, how the <code>container_of</code> macro works in the <code>onebyte_open</code> function, and how it's used to retrieve the <code>onebyte_data</code> structure.</p> <p>Additionally, Provide an explanation as to why the <code>onebyte_data</code> structure is stored as the private data of the file instead of being stored as a global variable?</p> <p>Compile the code and load the module. You may find that the entry in the \"/dev\" directory is not automatically created when the module is loaded. These device files need to be created either:</p> <ul> <li>manually using the <code>mknod</code> command, which creates a special file that   represents the device file, or</li> <li>automatically by the \"udev\" daemon.</li> </ul> <p>For this task, we create the device file manually using the <code>mknod</code> command.</p> <p>Question</p> <p>Provide the exact <code>mknod</code> command you used to create the device file.</p> <p>Here's the expected behaviour of the device:</p> <pre><code>$ sudo insmod onebyte.ko\n$ xxd /dev/onebyte\n00000000: ff                                       .\n$ echo 'a' &gt; /dev/onebyte\nbash: echo: write error: File too large\n$ xxd /dev/onebyte\n00000000: 61                                       a\n$ echo -n 'b' &gt; /dev/onebyte\n$ xxd /dev/onebyte\n00000000: 62                                       b\n$ sudo rmmod onebyte\n$ sudo insmod onebyte.ko\n$ xxd /dev/onebyte\n00000000: ff                                       .\n</code></pre>"},{"location":"asg4/task-cloudinit/","title":"Task 0: Cloud-Init","text":"<p>In Assignment 1, we delved into using QEMU to traverse the boot procedure of a system, from BIOS to Ubuntu. Additionally, Assignment 2 highlighted the potency of QEMU in conjunction with GDB for understanding and debugging the kernel.</p> <p>For this assignment, we'll use QEMU to emulate a non-existent peripheral device and develop a device driver for it. But before diving into that, let's establish a production-level virtual machine using QEMU, transitioning away from a testing environment.</p>"},{"location":"asg4/task-cloudinit/#step-1-boot-using-a-cloud-image","title":"Step 1: Boot using A Cloud Image","text":"<p>In Assignment 1, we used a RootFS archive to create a disk image, which did not involve any boot components.  For this task, we will boot from a cloud image, which is a disk image containing a bootable operating system.</p> <p>Download the cloud image from the following link: https://cloud-images.ubuntu.com/releases/22.04/release/ubuntu-22.04-server-cloudimg-amd64.img</p> <p>We can directly boot from this image, but doing so would modify it. In a real cloud environment, numerous virtual machines can be booted from the same image, so we prefer not to alter the image itself. Instead, we create a new disk image that is backed by the cloud image.</p> <pre><code>qemu-img create -f qcow2 -b ubuntu-22.04-server-cloudimg-amd64.img -F qcow2 hdd.qcow2 10G\n</code></pre> <p>Then, you can boot the image using the following command:</p> <pre><code>qemu-system-x86_64 -smp 2 -m 2G -nographic hdd.qcow2\n</code></pre> <p>Here, the <code>-smp</code> option specifies the number of CPUs, and the <code>-m</code> option specifies the amount of memory. You can adjust these values based on your system's resources.</p>"},{"location":"asg4/task-cloudinit/#step-2-customize-your-vm-using-cloud-init","title":"Step 2: Customize your VM using Cloud-Init","text":"<p>I assume you have been trying to log in to the VM but failed because you don't know the password.  Similar to what we experienced in Assignment 1, there isn't a user account created in the VM by default. Hence, we need to create one before logging in.</p> <p>Previously, we booted into the system in single-user mode to create a user, but this approach isn't scalable. In a cloud environment, we can utilize a tool called cloud-init to automate the process of creating a user account or other configurations. Let's follow the tutorial.</p> <p>First, create a directory to contain the files needed for cloud-init.</p> <p>Then, within the directory, create a file named <code>user-data</code> with the following content. Make sure to replace the username and password placeholders with your own.</p> <p>Additionally, create two more files:</p> <ol> <li> <p><code>meta-data</code> with the following content:</p> <pre><code>instance-id: someid/somehostname\n</code></pre> </li> <li> <p><code>vendor-data</code>, which can be empty.</p> </li> </ol> <p>Finally, launch an HTTP server in the directory to host these files.</p> <pre><code>$ python3 -m http.server\n</code></pre> <p>Now you can boot the VM with cloud-init enabled.</p> <pre><code>qemu-system-x86_64 -smp 2 -m 2G -nographic -nic user \\\n  -smbios type=1,serial=ds='nocloud;s=http://10.0.2.2:8000/' \\\n  hdd.qcow2\n</code></pre> <p>In addition to the regular kernel outputs, you should see some cloud-init logs. Eventually, you'll see something like \"Reached target Cloud-init target.\" After pressing \"Enter,\" you should encounter the login prompt. You can now log in using the username and password specified in <code>user-data</code>.</p> <p>This is just a piece of cake for cloud-init.  You can accomplish even more with it, such as setting up SSH keys, installing packages, and running scripts. For further information, you can refer to the examples.</p>"},{"location":"asg4/task-cloudinit/#step-3-ssh-into-the-vm","title":"Step 3: SSH into the VM","text":"<p>If you want to login to the VM using SSH, you can forward the SSH port from the host to the VM.  You can do this by changing <code>-nic</code> option in the command</p> <pre><code>qemu-system-x86_64 -smp 2 -m 2G -nographic -nic user,hostfwd=tcp::2222-:22 hdd.qcow2\n</code></pre> <p>You can change the port number <code>2222</code> to any other port number you prefer.</p>"},{"location":"asg4/task-cloudinit/#step-4-install-a-new-kernel","title":"Step 4: Install a New Kernel","text":"<p>The kernel version in the cloud image is not v6.7, which is the version we will use for the rest of the assignments. You can either build the kernel from source and install it in the VM, or if you have a pre-built kernel on your host machine, you can build a deb package and install it in the VM.</p>"},{"location":"asg4/task-interrupt/","title":"Task 3: Interrupt handler","text":"<p>Note</p> <p>You're to use the same environment as in the previous task.</p> <p>The PCI device we're dealing with in this task can calculate the factorial of a number. By properly setting the status register, it will raise an interrupt after finishing the computation.</p> <p>In this task, we've provided you with framework code for the device driver. Your job is to implement the interrupt handler and the service routines (open, close, read, and write) of the misc device.</p> <p>Here's the device specification:</p> <ul> <li>The device file can only be opened at most once at any time. If the device   file has already been opened when attempting to open it again, the handler   should return <code>-EBUSY</code>.</li> <li>While the device is calculating the factorial, the device file cannot be   opened until the computation is finished. If the device file is opened while   the device is calculating the factorial, the handler should return <code>-EBUSY</code>.</li> <li>The device file must be opened with either the <code>O_WRONLY</code> flag or the   <code>O_RDONLY</code> flag, not both. If the flag is not properly set, the handler should   return <code>-EINVAL</code>.</li> <li>If the file is opened with the <code>O_WRONLY</code> flag, you can write a number to the   device file. The device will start calculating the factorial of the number   when you close the file.</li> <li>If the file is opened with the <code>O_RDONLY</code> flag, you can read the result of the   factorial calculation.</li> <li>The driver must rely on the interrupt to be notified that the calculation is   finished. Polling to check if the calculation is finished is not allowed.</li> <li>Your driver must be free of memory errors. Deadlock should not occur in the   driver under any circumstances.</li> </ul> <p>Here's the expected behavior of the device:</p> <pre><code>$ sudo insmod edu.ko\n$ echo 1 | sudo tee /dev/factorial0\n1\n$ sudo cat /dev/factorial0\nfact(1) = 1\n$ echo 5 | sudo tee /dev/factorial0\n5\n$ sudo cat /dev/factorial0\nfact(5) = 120\n$ echo x | sudo tee /dev/factorial0\nx\n$ sudo cat /dev/factorial0\nfact(5) = 120\n$ echo 12 &gt; tmp.in\n$ sudo dd if=tmp.in of=/dev/factorial0 bs=1\n3+0 records in\n3+0 records out\n3 bytes copied, 4.9727e-05 s, 60.3 kB/s\n$ sudo dd if=/dev/factorial0 of=tmp.out bs=1\n21+0 records in\n21+0 records out\n21 bytes copied, 0.00015907 s, 132 kB/s\n$ sudo cat tmp.out\nfact(12) = 479001600\n$ sudo rmmod edu\n</code></pre> <p>Question</p> <p>Please finish the implementation under the directory <code>task3-factorial/</code> in the repository.</p>"},{"location":"asg4/task-pcidev/","title":"Task 2: PCI Device","text":"<p>A PCI (Peripheral Component Interconnect) device is a type of hardware device that connects to a computer's motherboard using the PCI interface. PCI devices can be internal or external and are used for a wide range of applications, such as graphics and audio processing, networking, and storage. The PCI bus is a high-speed data path that allows the CPU to communicate with the device and provides a common interface for a variety of hardware devices. PCI devices are identified by a unique vendor ID and device ID and require a specific driver to communicate with the operating system. They can be added or removed while the computer is running, making them a convenient and flexible option for expanding a system's capabilities.</p> <p>In this task, you will be emulating a PCI device using QEMU and interacting with it. The first step in this process is to set up the QEMU environment.</p>"},{"location":"asg4/task-pcidev/#step-1-launch-a-vm-on-qemu","title":"Step 1: Launch a VM on QEMU","text":"<p>Continuing from the steps outlined in Task 0, add an additional flag to the QEMU command to emulate the PCI device.</p> <pre><code>  -device edu\n</code></pre> <p>You can add more copies of the <code>-device edu</code> flag to create multiple instances of the PCI device.</p>"},{"location":"asg4/task-pcidev/#step-2-explore-the-pci-device","title":"Step 2: Explore the PCI device","text":"<p>Use the <code>lspci</code> command to discover the PCI slot name of the device with a vendor ID of 0x1234 and a device ID of 0x11e8. Refer to the man page of the <code>lspci</code> command for additional information if needed.</p> <p>Linux provides a mechanism to access PCI device resources through the sysfs. You can read the kernel documentation on Accessing PCI device resources through sysfs. As a next step, you can use the <code>hexdump</code> command to read the content of the PCI device's configuration space. Refer to the specification of the PCI configuration space, available here, to make sense of the output.</p> <p>The file <code>resource0</code> in the directory is mapped to the device's memory-mapped I/O (MMIO) area, and part of its specification is given below.</p> <pre><code>MMIO area spec\n--------------\n\nOnly size == 4 accesses are allowed for addresses &lt; 0x80. size == 4 or\nsize == 8 for the rest.\n\n0x00 (RO) : identification (0xRRrr00edu)\n            RR -- major version\n            rr -- minor version\n\n0x04 (RW) : card liveness check\n            It is a simple value inversion (~ C operator).\n\n0x08 (RW) : factorial computation\n            The stored value is taken and factorial of it is put back here.\n            This happens only after factorial bit in the status register (0x20\n            below) is cleared.\n\n0x20 (RW) : status register, bitwise OR\n            0x01 -- computing factorial (RO)\n            0x80 -- raise interrupt after finishing factorial computation\n</code></pre> <p>You may find the source code of the device here and a full copy of its specification here.</p> <p>However, when attempting to read the first four bytes of the file using the <code>head -c 4 resource0</code> command, an \"Input/output error\" is encountered:</p> <pre><code># head -c 4 resource0\nhead: error reading 'resource0': Input/output error\n</code></pre> <p>Question</p> <p>Why can't we read from the file <code>resource0</code>?</p> <p>Hint:</p> <ul> <li>According to the   documentation,   <code>rw</code> access is allowed for <code>IORESOURCE_IO</code> regions only in files named   <code>resource0..N</code>.</li> <li>You should refer to the information from the configuration space.</li> </ul>"},{"location":"asg4/task-pcidev/#step-3-access-the-pci-device","title":"Step 3: Access the PCI device","text":"<p>Since the file is mmapable, we can use the <code>mmap</code> system call to map the file into the process's address space and then access the device's registers. For more information about the <code>mmap</code> system call, you can refer to the man page.</p> <p>Please write a program that accepts two arguments:</p> <ol> <li>The path to the PCI device's \"resource0\".</li> <li>A 32-bit unsigned integer in hexadecimal format.</li> </ol> <p>The program should successfully output the identification of the device and the inversion of the given number.</p> <p>Here's the expected behavior of the program:</p> <pre><code>$ sudo ./pci-mmap /sys/path/to/the/device/resource0 0x11111111\nIdentification: 0x010000edu\n     Inversion: 0xeeeeeeee\n</code></pre> <p>Tip</p> <p>You should be able to accomplish the task by inserting some lines in the given slot. However, feel free to modify other parts of the code if needed.</p> <p>Question</p> <p>Please finish the implementation under the directory <code>task2-mmap/</code> in the repository.</p>"}]}